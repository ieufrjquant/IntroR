[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R e RStudio para Iniciantes",
    "section": "",
    "text": "Prefácio",
    "crumbs": [
      "Prefácio"
    ]
  },
  {
    "objectID": "index.html#o-que-você-vai-aprender",
    "href": "index.html#o-que-você-vai-aprender",
    "title": "R e RStudio para Iniciantes",
    "section": "O que você vai aprender",
    "text": "O que você vai aprender\nPretendemos que você domine o mínimo necessário de programação em R para executar as tarefas que podem ser requisitadas pelo seu professor, independentemente do curso da área quantitativa em que estiver. Em outras palavras, se te pedirem algo que deva ser elaborado com auxílio de programação em R, você será capaz de fazê-lo após ler este material1.\nNa prática, o quê significa dominar o mínimo necessário de programação em R? Inclui entender alguns conceitos básicos – para quê serve a programação em nosso contexto, o que é a linguagem de programação R, o que é o RStudio, entre outros – assim como a sintaxe da linguagem – ou seja, o ato de escrever um código interpretável propriamente dito.",
    "crumbs": [
      "Prefácio"
    ]
  },
  {
    "objectID": "index.html#o-que-você-não-vai-aprender",
    "href": "index.html#o-que-você-não-vai-aprender",
    "title": "R e RStudio para Iniciantes",
    "section": "O que você não vai aprender",
    "text": "O que você não vai aprender\nNão estamos em um curso de Ciência da Computação: você não irá aprender terminologias difíceis e/ou como a programação, de modo geral, funciona nos detalhes. Em outras palavras, vamos nos concentrar apenas em entender o necessário para construir e executar códigos em R (não se preocupe, ainda explicaremos o que é um código em R) a partir das tarefas que seu professor poderá pedir.\nAlém disso, o material não te dará proficiência em R. O que queremos dizer com isso? Bom, queremos dizer que você não será uma pessoa que dominará o R de forma avançada. Novamente: aqui, te ensinaremos apenas o necessário para que consiga concluir os cursos da área quantitativa. Mas, se você realmente quiser alcançar níveis mais altos, alguns livros podem te ajudar:\n\nR for Data Science (2ª edição)\nCiência de Dados em R\nData Science for Psychologists\nAn Introduction to R for Research",
    "crumbs": [
      "Prefácio"
    ]
  },
  {
    "objectID": "index.html#preciso-saber-alguma-coisa-de-forma-antecipada",
    "href": "index.html#preciso-saber-alguma-coisa-de-forma-antecipada",
    "title": "R e RStudio para Iniciantes",
    "section": "Preciso saber alguma coisa de forma antecipada?",
    "text": "Preciso saber alguma coisa de forma antecipada?\nNão. Você não precisa saber absolutamente nada de programação em R – não precisa nem mesmo saber o que o termo programação significa. O intuito do material é justamente te introduzir aos conceitos mais básicos!\nA única coisa que você precisará será de acesso à um computador com internet. Utilizar um computador é necessário pois é nele onde ocorre o ato de programar; ter internet é importante porquê, ao longo dos captíulos, precisaremos que você realize o download de certos arquivos – seja para instalar o R e o RStudio ou para importar algum arquivo diretamente para este último (não se preocupe, ainda explicaremos o que importação de um arquivo significa).",
    "crumbs": [
      "Prefácio"
    ]
  },
  {
    "objectID": "index.html#como-o-material-está-organizado",
    "href": "index.html#como-o-material-está-organizado",
    "title": "R e RStudio para Iniciantes",
    "section": "Como o material está organizado",
    "text": "Como o material está organizado\nO material está organizado em oito capítulos: o primeiro, que te mostra a motivação para programar, além de outros sete que buscam, em primeiro lugar, te guiar na instalação do R e RStudio e, na sequência, ensinar comandos e conceitos básicos que serão necessários ao longo dos cursos. Com intuito de facilitar o aprendizado, cada capítulo foi repartido em um certo número de seções (e subseções, quando necessário).\nA lista de capítulos pode ser observada no menu à esquerda. Por sua vez, a lista de seções do capítulo em que você estiver pode ser observada no menu à direita. Perceba que, para ser direcionado a um determinado capítulo/seção, basta clicar em seu nome.\n\n\n\n\n\n“Caramba, queria tanto acessar uma parte específica do material que não lembro muito bem onde está… E agora?” Sem problemas: você pode pesquisar partes do texto ou palavras-chave no campo em branco logo acima do Prefácio!",
    "crumbs": [
      "Prefácio"
    ]
  },
  {
    "objectID": "index.html#dúvidas-e-sugestões-com-quem-falar",
    "href": "index.html#dúvidas-e-sugestões-com-quem-falar",
    "title": "R e RStudio para Iniciantes",
    "section": "Dúvidas e sugestões: com quem falar?",
    "text": "Dúvidas e sugestões: com quem falar?\n“Ué, no meu computador não aparece isso!”\n“Caramba, achei aquele trechinho ali meio confuso… podia melhorar…”\n“Nossa, que material show!”\nSurgiu alguma dúvida ou então quer dar alguma sugestão de melhoria? Estamos totalmente abertos à qualquer tipo de crítica! Envie uma mensagem para pedro.hemsley@ie.ufrj.br.",
    "crumbs": [
      "Prefácio"
    ]
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "R e RStudio para Iniciantes",
    "section": "",
    "text": "Esperamos que os empecilhos que apareçam não sejam por conta de alguma dificuldade no ato de programar em si, mas por dúvidas com relação à matéria propriamente dita. De qualquer forma, fique tranquilo: se você não entendeu alguma parte do material, estaremos sempre abertos a te ajudar!↩︎",
    "crumbs": [
      "Prefácio"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Por que programar?",
    "section": "",
    "text": "1.1 Redução no tempo de cálculo\nA primeira vantagem é a redução no tempo de cálculo de certos procedimentos que, se feitos de forma manual, levariam vários minutos, horas ou até mesmo dias. Vamos deixar mais claro com um exemplo.\nNo ensino fundamental, você aprendeu a resolver um sistema de equações simultâneas com \\(2\\) equações e \\(2\\) incógnitas, muito provavelmente pelo método de substituição. Não levava muito tempo, certo? Acontece que, na cadeira de Álgebra Linear, você aprenderá como identificar a existência e encontrar a solução de sistemas com muitas equações e muitas variáveis – dado que, ao longo do curso, você terá contato com sistemas determinísticos maiores cujo objetivo é explicar a realidade de forma simplificada. Nos que possuem solução, quanto mais complexo for o sistema, maior será a dificuldade de encontrá-la. Durante o curso, você aprenderá métodos que permitem descobrir a resolução de sistemas desse tipo de forma mais rápida, pelo menos em relação ao método de substituição. No entanto, certo tempo continuará sendo perdido se você os replicar manualmente.\nCom auxílio da programação, é possível implementar estes mesmos métodos para obter o resultado de forma quase que instantânea! O tempo que você levaria realizando o procedimento de forma manual se reduz próximo a zero – ou fica mínimo, comparado ao tempo que seria gasto se você resolvesse, na mão, todos os cálculos inerentes ao método em questão.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Por que programar?</span>"
    ]
  },
  {
    "objectID": "intro.html#redução-no-tempo-de-cálculo",
    "href": "intro.html#redução-no-tempo-de-cálculo",
    "title": "1  Por que programar?",
    "section": "",
    "text": "Observe que você ainda deve focar em saber como os métodos funcionam, do contrário não será capaz de julgar se o que a máquina fez é realmente aquilo que você desejava!",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Por que programar?</span>"
    ]
  },
  {
    "objectID": "intro.html#automação-de-processos",
    "href": "intro.html#automação-de-processos",
    "title": "1  Por que programar?",
    "section": "1.2 Automação de processos",
    "text": "1.2 Automação de processos\nNa seção anterior, repare que estavamos discorrendo implicitamente sobre cálculos de ocorrência única – ou seja, realizamos o cálculo uma vez e não teríamos mais interesse de fazê-lo novamente em um futuro próximo. Porém, é importante destacar que outro benefício prático do ato de programar é a automação de tarefas repetitivas. Com a programação, é possível escrever e salvar códigos que realizam as mesmas tarefas tediosas de manipulação e análise de dados sempre que necessário, permitindo que os pesquisadores se concentrem em questões analíticas de maior relevância.\nPor exemplo, imagine que alguém te peça para calcular a média de alguns valores, digamos dez, que mudam de dia para dia. Você poderia facilmente elaborar um código que, a partir de determinados números (independente de quais sejam), calcule a média correspondente. Uma vez o código escrito e salvo, você pode passar a executá-lo sempre que quiser – no nosso exemplo, você o executaria todos os dias. Repare que calcular a média uma única vez não seria um problema; no entanto, esse procedimento simples se torna custoso quando temos que repetí-lo todo dia. Ao automatizar a tarefa, o pesquisador pode concentrar o tempo economizado no cálculo para, por exemplo, pensar sobre o porquê da média ter apresentado aquele determinado valor.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Por que programar?</span>"
    ]
  },
  {
    "objectID": "intro.html#vamos-programar-em-r",
    "href": "intro.html#vamos-programar-em-r",
    "title": "1  Por que programar?",
    "section": "1.3 Vamos programar… em R!",
    "text": "1.3 Vamos programar… em R!\nEm suma, aprender a programar oferece uma série de vantagens tangíveis para quem trabalha com estatística e matemática. Ela tornar o trabalho mais eficiente e produtivo, permitindo que os profissionais explorem dados de maneiras antes inimagináveis e desenvolvam soluções personalizadas para os desafios enfrentados em suas áreas de atuação.\nNo restante do material, aprenderemos a programar utilizando a linguagem de programação R. Em outras palavras, aprenderemos (i) sua sintaxe, isto é, a forma correta de escrever comandos para que a máquina seja capaz de interpretar o que queremos como resultado, e (ii) como executar códigos que foram escritos.\nVocê deve estar se perguntando: “Por que programar em R?”. Simplesmente pois é uma linguagem de programação moldada para executar tarefas estatísticas (e matemáticas, em menor grau). Não à toa, é amplamente utilizada por economistas que desejam constuir e testar hipóteses sobre seus modelos e automatizar coleta de dados econômicos.\n\n\n\n\n\n\nAo longo da apostila, existem conteúdos que são opcionais, ou seja, você pode pulá-los sem prejuízo para a sequência do material. Pense neles como se fossem aprofundamentos. Sem tempo? Pode passar direto! Eles estarão dispostos em boxes expandíveis, como abaixo.\n\n\n\n\n\n\n\n\n\nOutros exemplos de linguagem de programação (Opcional)\n\n\n\n\n\nO R é a linguagem que escolhemos para utilizar nos nossos cursos. Mas é interessante que você saiba que existem outras linguagens de programação por aí – algumas capazes de executar papel semelhante ao próprio R. Em 2023, as linguagens de programação mais utilizadas foram: JavaScript (63% dos programadores que responderam uma pesquisa disseram que a utilizavam1), Python (49%) e SQL (48%).\nApenas 4% dos respondentes tiveram contato com R. ‘Meu Deus, estamos usando uma linguagem que poucas pessoas usam!’ você pode estar pensando agora. Calma, não é bem assim! Realmente, em comparação ao Python e SQL, o R é menos utilizado. Mas, em número absoluto, a comunidade é grande. Além disso, é bom ter em mente que cada linguagem de programação tem suas vantagens e desvantagens e, por esse motivo, é preciso entender o contexto no qual você quer utilizá-la. O R foi escolhido por sua disponibilidade e eficiência computacional em relação à métodos estatísticos e matemáticos – ideal para cursos de estatística e matemática!",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Por que programar?</span>"
    ]
  },
  {
    "objectID": "intro.html#footnotes",
    "href": "intro.html#footnotes",
    "title": "1  Por que programar?",
    "section": "",
    "text": "Fonte: Statista↩︎",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Por que programar?</span>"
    ]
  },
  {
    "objectID": "intro-instalacao.html",
    "href": "intro-instalacao.html",
    "title": "Instalação",
    "section": "",
    "text": "Nessa parte, você irá aprender como baixar e instalar o R e o RStudio, além da composição de layout de ambos. Construímos cada seção de instalação como um guia do tipo passo a passo, de maneira que você precisa apenas seguí-los de forma direta. Neste capítulo, é importante que você já comece a explorar um pouco a interface dos ambientes de programação que te mostraremos.",
    "crumbs": [
      "Instalação"
    ]
  },
  {
    "objectID": "instalando-r.html",
    "href": "instalando-r.html",
    "title": "2  Instalando o R",
    "section": "",
    "text": "2.1 Sete passos\nApós o final da instalação, você deverá ser capaz de encontrar e abrir no seu computador o R Graphical User Interface ou, como popularmente é conhecido, RGui. Ele estará na pasta em que você destinou para instalação; no Windows, algo próximo de:\nC:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\R",
    "crumbs": [
      "Instalação",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Instalando o R</span>"
    ]
  },
  {
    "objectID": "instalando-r.html#sete-passos",
    "href": "instalando-r.html#sete-passos",
    "title": "2  Instalando o R",
    "section": "",
    "text": "O primeiro passo consiste em escolher um repositório (mirror) para baixar o R. No endereço https://cran.r-project.org/mirrors.html encontramos todas as opções disponíveis, por país e em ordem alfabética. No seu computador, deverá aparecer a seguinte tela:\n\n\n\n\n\nPor questões de rapidez/latência, o ideal é escolher o repositório mais próximo de você. Considerando que todos estejam no Rio de Janeiro, vamos então utilizar o mirror da Fiocruz.\n\n\n\n\n\nComo essa apostila foca na instalação para sistemas operacionais do tipo Windows, vamos clicar então em Download R for Windows, na parte superior da página.\n\n\n\n\n\nNa página seguinte, clique em ‘base’. Grosso modo, como o nome já indica, iremos baixar os aquivos base do R – ou seja, o mínimo necessário que você precisará para poder executar algum código.\n\n\n\n\n\nNa nova página, clique em ‘Download R x.x.x for Windows’, sendo ‘x.x.x’ o número da versão que será baixada. No momento da elaboração deste tutorial, a versão mais recente do R é a 4.3.3.\n\n\n\n\n\nSe você tiver algum problema com o download, tente escolher outro servidor no passo 2 – por exemplo, um dos servidores da Universidade de São Paulo.\n\n\n\n\n\n\n\nEncontrando o caminho!\n\n\n\nAbaixo, os passos 1-5 para realizar o donwload.\n\n\n\n\n\n\n\n\nVocê receberá um aviso, que varia conforme o navegador em uso, de que o arquivo está sendo baixado. Abaixo, um exemplo no Microsoft Edge:\n\n\n\n\n\nNo Windows, o arquivo será armazenado na pasta ‘Downloads’ do seu computador (ou na pasta que você previamente configurou como destino para os arquivos baixados).\nFeito o download, clique duas vezes no arquivo baixado e siga as instruções para instalação. Na prática, basta clicar em ‘Avançar’ até o fim.",
    "crumbs": [
      "Instalação",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Instalando o R</span>"
    ]
  },
  {
    "objectID": "instalando-r.html#conhecendo-o-rgui",
    "href": "instalando-r.html#conhecendo-o-rgui",
    "title": "2  Instalando o R",
    "section": "2.2 Conhecendo o RGui",
    "text": "2.2 Conhecendo o RGui\nDe forma geral, um GUI permite com que o usuário utilize a linguagem de forma interativa através de botões e dispositivos visuais. Observe que, na parte superior, temos oito botões principais, representados por pequenas imagens.\n\n\n\n\n\nCada botão executa uma tarefa específica. Os três primeiros, da esquerda para direita, são os mais relevantes:\n\n‘Abrir script’: permite com que você carregue, no Editor de Código, um arquivo que contém linhas de código (script). Arquivos desse tipo, cuja extensão é .R, serão os mais importantes da linguagem.\n‘Carregar área de trabalho’: importa objetos que foram salvos anteriormente em um arquivo do tipo .RData.\n‘Salvar área de trabalho’: salva objetos criados em um arquivo do tipo .RData.\n\nOs botões restantes, em ordem, executam as seguintes tarefas: ‘Copiar’, ‘Colar’, ‘Copiar e colar’, ‘Parar computação atual’ e ‘Imprimir’. Nesse momento, não se preocupe em saber o que significa importar ou o que é um arquivo do tipo .RData.\nPor outro lado, vamos procurar entender melhor o que são o Console e o Editor de Código. O primeiro corresponde à janela de nome R Console, no canto esquerdo da sua tela. Este último, por sua vez, não abre instantâneamente no momento em que você acessa o RGui, mas podemos abrí-lo manualmente através de ‘Arquivo’ &gt; ‘Novo script’ – ou, então, carregando um script já existente através do botão ‘Abrir script’, que vimos anteriormente. Posicionando o Editor de Código ao lado do Console, teremos a seguinte imagem:\n\n\n\n\n\nPor quê esses espaços terão relevância para nós?\n\nO Editor de Código é o local em que você escreve os comandos que deseja executar no R, além de comentários que busquem registrar o porquê de você ter escrito determinada parte do seu código. Na prática, um comentário é uma linha que não será interpretada – e consequentemente executada – como parte da linguagem. Para registrar um comentário, basta escrever o símbolo ‘#’ antes do que você deseja escrever naquela linha2. Um ponto importante: o Editor permite com que salvemos o script que criamos em um arquivo do tipo .R. Lembre-se: esse é o principal tipo de arquivo da linguagem.\nO Console, por sua vez, é o local em que a parte interpretável de código em R (ou seja, tudo exceto comentários) será efetivamente executada e os respectivos resultados serão mostrados. É aqui que a mágica efetivamente ocorre! Você também pode executar partes do seu código diretamente no Console, porém os comandos não ficam salvos, são apenas temporários.\n\nSimplificando: o Editor é o espaço em que você realmente escreverá os códigos em R. Ele atua como rascunho do seu script, permitindo com que você posteriormente salve o que foi escrito e, consequentemente, volte a executar o mesmo código. Já o Console é o espaço em que o código é processado, retornando com o resultado dos comandos que você escreveu.\nEntretanto, não iremos utilizá-los através do RGui. No capítulo seguinte, instalaremos e conheceremos um pouco mais sobre outro ambiente, bem mais completo, para se programar em R. “Meu Deus, aprendi todos esses conceitos à toa?”, você deve estar se perguntando. Não! Muito do que aprendemos nessa seção voltará a aparecer no capítulo seguinte.\n\n\n\n\n\n\nExecutando um simples código no RGui (Opcional)\n\n\n\n\n\nBeleza, não tocaremos no RGui. Mas é interessante compreender que já é possível executar – ou rodar, no jargão de programação – algum pedaço de código – ou chunk – escrito em R. Para isso, basta escrevê-lo após o símbolo de ‘maior que’ (&gt;) no Console.\nVamos entender com um rápido exemplo. No GIF abaixo, atribuimos à variável de nome x o valor númerico 2. Em seguida, escrevemos o nome novamente para retornar seu valor. Fique tranquilo: ainda iremos ver melhor o que significam termos como atribuir um valor à determinada variável. O objetivo deste box foi apenas te mostrar que já estamos aptos a programar em R!",
    "crumbs": [
      "Instalação",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Instalando o R</span>"
    ]
  },
  {
    "objectID": "instalando-r.html#footnotes",
    "href": "instalando-r.html#footnotes",
    "title": "2  Instalando o R",
    "section": "",
    "text": "Você pode realizar procedimento equivalente para sistemas operacionais Linux, apenas alterando a opção de download quando necessário – isto é, selecionando as opções em que esteja escrito ‘Linux’, ao invés de ‘Windows’.↩︎\nNote que, se o seu comentário for longo demais, de tal forma que você queira quebrá-lo em duas ou mais linhas, será necessário novamente escrever ‘#’ na próxima linha↩︎",
    "crumbs": [
      "Instalação",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Instalando o R</span>"
    ]
  },
  {
    "objectID": "instalando-rstudio.html",
    "href": "instalando-rstudio.html",
    "title": "3  Instalando o RStudio",
    "section": "",
    "text": "3.1 Três passos\nPara instalar o RStudio no Windows, novamente iremos seguir alguns passos – nesse caso, apenas 3:\nAo final da instalação, você deverá ser capaz de abrir o RStudio no seu computador, resultando em algo similar à imagem abaixo. No Windows, provavelmente você o encontrará no caminho:\nC:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\RStudio\nFeito? Então estamos prontos para utilizar o R através do RStudio!",
    "crumbs": [
      "Instalação",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Instalando o RStudio</span>"
    ]
  },
  {
    "objectID": "instalando-rstudio.html#três-passos",
    "href": "instalando-rstudio.html#três-passos",
    "title": "3  Instalando o RStudio",
    "section": "",
    "text": "Acesse a página de downloads da RStudio: https://posit.co/download/rstudio-desktop/#download. Se você tiver acesso de administrador, basta clicar em ‘Download RStudio Desktop for Windows’.\n\n\n\n\n\nDe forma análoga ao download do R, você receberá um aviso de que o arquivo está sendo baixado (na sua pasta de ‘Downloads’ ou similar).\n\n\n\n\n\nClique duas vezes no arquivo que você baixou e siga as instruções recomendadas de instalação, cuja tela inicial está na imagem abaixo.",
    "crumbs": [
      "Instalação",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Instalando o RStudio</span>"
    ]
  },
  {
    "objectID": "instalando-rstudio.html#conhecendo-o-rstudio",
    "href": "instalando-rstudio.html#conhecendo-o-rstudio",
    "title": "3  Instalando o RStudio",
    "section": "3.2 Conhecendo o RStudio",
    "text": "3.2 Conhecendo o RStudio\n\n\n\n\n\n\nNota\n\n\n\nA seção 3.2 ‘Conhecendo o RStudio’ é baseada na seção 2.1 ‘Telas’ do livro Ciência de Dados em R, feito pelo Curso-R. De qualquer modo, eventuais erros são inteiramente de nossa responsabilidade.\n\n\nO RStudio será o ambiente no qual iremos trabalhar com a linguagem. Por essa razão, é muito importante que você se sinta confortável com o que verá no seu computador após abrí-lo. Nessa seção, iremos compreender melhor o layout do RStudio, além das utilidades que ele nos proporciona ao longo do processo de escrita dos códigos.\nAo abrir o RStudio pela primeira vez (como na imagem anterior), você verá inicialmente 3 quadrantes. Um deles, preenchendo a parte esquerda da tela, já conhecemos: é o Console, que cumpre o mesmo papel explicado no capítulo anterior. Ao mesmo tempo, o quadrante que mais utilizaremos não aparece inicialmente: é o Editor de Código, outro velho conhecido que também possui a mesma atribuição anterior. Tal como no caso do RGui, o Editor não abre automaticamente pois o RStudio não é capaz de saber se o usuário tem o desejo de construir um código do zero – ou seja, criar um novo arquivo com extensão .R – ou apenas dar continuidade à algum em que já estava trabalhando.\nNo fim das contas, teremos 4 quadrantes:\n\n\n\n\n\n\n\nPor padrão, os quadrantes estarão dispostos na sua tela da forma como mostramos na imagem acima, mas você pode organizá-los da forma que preferir acessando a seção Pane Layout da opção Global options... no menu Tools.\n\n\n\nÉ importante que você entenda que o Editor e o Console são os dois principais quadrantes do RStudio. Passaremos a maior parte do tempo neles. Como não custa nada, vamos relembrar suas respectivas serventias:\n\nEditor de Código: é local em que escreveremos/editaremos nossos códigos, salvando posteriormente em um arquivo do tipo .R. Conforme formos avançando, você acabará reparando que temos algumas melhorias em relação ao RGui:\n\nO RStudio colore algumas palavras e símbolos para facilitar a leitura do código. Por exemplo, tudo o que for comentário será de uma determinada cor, assim como tudo que você escrever entre aspas – considerado texto passível de ser executado como parte de um código – será de outra.\nOutra funcionalidade interessante do Editor no RStudio é a capacidade de você poder buscar e substituir determinadas palavras/expressões que estejam presentes no código, poupando tempo e evitando erros caso o fizessemos de forma maunal; para tal, basta clicar no símbolo da lupa logo acima da primeira linha.\nAlém disso, o RStudio possui o recurso de autocompletar partes de um código! Caso você esteja escrevendo o nome de um objeto que ele consiga identificar, receberá automaticamente uma sugestão para completar a escrita, bastando apertar a tecla Tab para aceitá-la.\n\nConsole: é local em que o código é executado e recebemos as saídas. Nele, temos também o recurso de autocompletar nomes de objetos. Para limpar o Console, isto é, excluir o registro do que já foi executado pelo R, basta clicar no símbolo de vassoura, no canto direito superior do quadrante, ou então utilizar o atalho Ctrl + L.\n\nOs demais quadrantes do lado direito contém painéis auxiliares. O objetivo deles é facilitar pequenas tarefas que fazem parte tanto da programação quanto da análise de dados como, por exemplo, olhar a documentação de funções, analisar os objetos criados em uma sessão do R, procurar e organizar os arquivos que compõem a nossa análise, armazenar e analisar os gráficos criados e muito mais.\nNo quadrante superior, temos\n\nEnvironment: painel com todos os objetos criados na sessão. Será bastante útil como referência para avaliar os objetos que criamos ou deixamos de criar com determinado comando.\nHistory: painel com um histórico dos comandos rodados.\n\nJá no quadrante inferior, temos\n\nFiles: mostra os arquivos no diretório de trabalho. Nele, é possível navegar entre as pastas do seu computador! Você pode, por exemplo, abrir um arquivo do tipo .R sem necessariamente ter que passar pela janela de busca do seu sistema operacional.\nPlots: painel onde os gráficos serão apresentados, caso você crie um código que os produza.\nPackages: apresenta todos os pacotes instalados e carregados.\nHelp: janela onde as documentações de funções serão apresentadas.\nViewer: painel onde relatórios e dashboards serão apresentados.\n\nAlém do Console e do Editor, dê atenção especial aos painéis Environment, Help e Plots, nesta ordem.",
    "crumbs": [
      "Instalação",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Instalando o RStudio</span>"
    ]
  },
  {
    "objectID": "intro-lingr.html",
    "href": "intro-lingr.html",
    "title": "R Básico",
    "section": "",
    "text": "Nessa parte do material, você aprenderá a programar na prática. O capítulo inicial terá como objetivo estimular que a escrita de suas primeiras linhas de código; será composto de tarefas super simples, mas suficientes para proporcionar uma primeira eperiência à quem nunca programou. Nos dois capítulos seguintes, te guiaremos no entendimento sobre os dois conceitos mais importantes da linguagem: objetos e funções. Segundo John Chambers, um dos desenvolvedores do R,\n\nto understand computations in R, two slogans are helpful:\n\nEverything that exists is an object.\nEverything that happens is a function call.\n\n\nMão na massa!",
    "crumbs": [
      "R Básico"
    ]
  },
  {
    "objectID": "prim-passos.html",
    "href": "prim-passos.html",
    "title": "4  Primeiros passos",
    "section": "",
    "text": "4.1 Operadores Aritméticos\nVamos começar com um exemplo simples! Vamos pedir ao R que some os números 1 e 1:\n1 + 1\n\n[1] 2\nNesse caso, o nosso comando foi o código 1 + 1 e a saída foi o valor 2. Como você pode reproduzir esse comando no RStudio? Inicialmente, copie o que está escrito acima ao clicar no símbolo de prancheta no canto superior direito da região sombreada. Na sequência, cole no Editor de Código e aperte Ctrl + Enter (ou então cole no Console, na sequência pressionando apenas Enter). Observe abaixo!\nTente agora jogar no Console a expressão: 2 * 2 - (4 + 4) / 2. Deu zero? Pronto! Você já é capaz de pedir ao R para fazer qualquer uma das quatro operações aritméticas básicas. Repare que as operações e suas precedências são mantidas como na matemática, ou seja, divisão e multiplicação são calculadas antes da adição e subtração, além de os parênteses ditarem a ordem na qual serão realizadas. A seguir, apresentamos a Tabela 4.1 resumindo como fazer as principais operações no R.\nTabela 4.1: Operadores matemáticos no R\n\n\n\n\n\n\nOperação\nOperador\nExemplo\nResultado\n\n\n\n\nAdição\n+\n1 + 1\n2.00\n\n\nSubtração\n-\n4 - 2\n2.00\n\n\nMultiplicação\n*\n2 * 3\n6.00\n\n\nDivisão\n/\n5 / 3\n1.67\n\n\nPotenciação\n^\n4 ^ 2\n16.00\n\n\nResto da Divisão\n%%\n5 %% 3\n2.00\n\n\nParte Inteira da Divisão\n%/%\n5 %/% 3\n1.00\nIncluímos os operadores de potênciação, resto e parte inteira de divisão. Na prática, não serão tão utilizados quanto os demais, mas é importante que você os veja pelo menos uma vez durante o processo de aprendizado.",
    "crumbs": [
      "R Básico",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Primeiros passos</span>"
    ]
  },
  {
    "objectID": "prim-passos.html#operadores-aritméticos",
    "href": "prim-passos.html#operadores-aritméticos",
    "title": "4  Primeiros passos",
    "section": "",
    "text": "De agora em diante, cada região sombreada de cinza e centralizada no documento representa um pedaço código. Quando couber, o resultado de sua execução no Console será exposto logo na sequência. Observe que você pode copiar o que está escrito ao passar o cursor sobre a região e clicar no símbolo de prancheta que aparecerá no canto direito superior.",
    "crumbs": [
      "R Básico",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Primeiros passos</span>"
    ]
  },
  {
    "objectID": "prim-passos.html#operadores-lógicos",
    "href": "prim-passos.html#operadores-lógicos",
    "title": "4  Primeiros passos",
    "section": "4.2 Operadores Lógicos",
    "text": "4.2 Operadores Lógicos\nO R permite também testar comparações lógicas. Os valores lógicos básicos em R são TRUE (ou apenas T) e FALSE (ou apenas F). Por exemplo, podemos pedir ao R que nos diga se é verdadeiro que 5 é menor do que 3. Como a resposta é obviamente negativa, ele retornará FALSE, nos dizendo que a proposição que fizemos é falsa.\n\n5 &lt; 3\n\n[1] FALSE\n\n\nAbaixo, introduzimos a Tabela 4.2 com outros operadores lógicos da linguagem.\n\n\n\n\nTabela 4.2: Operadores lógicos do R\n\n\n\n\n\n\n\n\n\n\n\n\nOperação\nOperador\nExemplo\nResultado\n\n\n\n\nMaior que\n&gt;\n2 &gt; 1\nTRUE\n\n\nMaior ou igual que\n&gt;=\n2 &gt;= 2\nTRUE\n\n\nMenor que\n&lt;\n2 &lt; 3\nTRUE\n\n\nMenor ou igual que\n&lt;=\n5 &lt;= 3\nFALSE\n\n\nIgual à\n==\n4 == 4\nTRUE\n\n\nDiferente de\n!=\n5 != 3\nTRUE\n\n\nNão x\n!\nx &lt;- c(1, 4, NA, 8)  !x\nTodos valores que não  1, 4, NA e 8\n\n\nx e y\n&\nx &lt;- c(1, 4, NA, 8)  x[!is.na(x) & x &gt; 5]\n8\n\n\nx ou y\n|\nx &lt;- c(1, 4, NA, 8)  x[!is.na(x) | x &gt; 5]\n1, 4, 8\n\n\n\n\n\n\n\n\nAo longo do material, explicaremos melhor esses oepradores.",
    "crumbs": [
      "R Básico",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Primeiros passos</span>"
    ]
  },
  {
    "objectID": "prim-passos.html#possíveis-complicações",
    "href": "prim-passos.html#possíveis-complicações",
    "title": "4  Primeiros passos",
    "section": "4.3 Possíveis complicações",
    "text": "4.3 Possíveis complicações\nEm determinado momento, você pode acabar executando errado algum trecho de código. Como o R se comporta nessas situações?\n\n4.3.1 Comando incompleto\nSe você digitar um comando incompleto no Console, como 5 +, e apertar Enter, o R mostrará um +, o que não tem nada a ver com a adição da matemática. Isso significa que o R está esperando você enviar mais algum código para completar o seu comando. Termine o seu comando ou aperte Esc para recomeçar.\n\n5 -\n+ \n+ 5\n\n[1] 0\n\n\n\n\n4.3.2 Comando inexistente na linguagem\nSe você digitar um comando que o R não reconhece, ele retornará uma mensagem de erro. Não entre em pânico. Ele só está te avisando que não conseguiu interpretar o comando. Imagine que queremos retornar a parte inteira da divisão de 5 por 2. Nesse caso, devemos digitar 5 %% 2 no Editor e rodar. Mas, se por engano, digitarmos 5 % 2?\n\n5 % 2\n\nError: &lt;text&gt;:1:3: unexpected input\n1: 5 % 2\n      ^\n\n\nNão existe um operador % no R, logo esse comando retorna erro! Você pode digitar o comando correto normalmente em seguida.\n\n5 %% 2\n\n[1] 1",
    "crumbs": [
      "R Básico",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Primeiros passos</span>"
    ]
  },
  {
    "objectID": "objetos.html",
    "href": "objetos.html",
    "title": "5  Objetos",
    "section": "",
    "text": "5.1 Dados\nSegundo a Oxford Languages, dados são\nNa prática, dados nos mostram informações sobre determinado indivíduo ou situação que procuramos descrever, seja uma pessoa, instituição, comportamento, condição geográfica, etc. O número de horas que você dormiu essa noite é um dado. A lista que relata quem é ou não calvo na sua família é uma coleção de dados. A expectativa, hoje, de quanto será a inflação acumulada nos próximos 12 meses é um dado. A variação percentual do Produto Interno Bruto (PIB) real no último trimestre é um dado. A lista que mostra a sequência de variações do PIB real nos últimos dez trimestres é uma série temporal, isto é, dados em sequência ao longo do tempo.",
    "crumbs": [
      "R Básico",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Objetos</span>"
    ]
  },
  {
    "objectID": "objetos.html#dados",
    "href": "objetos.html#dados",
    "title": "5  Objetos",
    "section": "",
    "text": "fatos e estatísticas coletadas de forma conjunta para referência ou análise.\n\n\n\n5.1.1 Tipo & Forma\nVamos nos aprofundar um pouco mais. Ao lidar formalmente com dados, devemos ter mente que eles são compostos por uma ou mais variáveis e seus valores. Uma variável é uma dimensão ou propriedade que descreve uma unidade de observação (por exemplo, uma pessoa) e normalmente pode assumir valores diferentes. Por outro lado, os valores são as instâncias concretas que uma variável atribui a cada unidade de observação e são ainda caracterizados por seu intervalo (por exemplo, valores categóricos versus valores contínuos) e seu tipo (por exemplo, valores lógicos, numéricos ou de caracteres). Estaremos interessados no tipo dos dados. A Tabela 5.1 apresenta os que podem aparecer com maior frequência.\n\n\n\n\nTabela 5.1: Tipos mais comuns de dados\n\n\n\n\n\n\n\n\n\n\n\nTipo\nServe para representar…\nExemplo\n\n\n\n\nNúmerico\nnúmeros do tipo integer (inteiro) ou double (reais)\n1, 3.2, 0.89\n\n\nTexto (string)\ncaracteres (letras, palavras ou setenças)\n“Ana jogou bola”\n\n\nLógico\nvalores verdade do tipo lógico (valores booleanos)\nTRUE, FALSE, NA lógico\n\n\nTempo\ndatas e horas\n14/04/1999\n\n\n\n\n\n\n\n\nVoltando ao primeiro exemplo, uma pessoa pode ser descrita pelas variáveis nome, número de horas dormidas e se dormiu ou não mais de oito horas. Os valores correspondentes a essas variáveis seriam do tipo texto (por exemplo, “Pedro”), numéricos (número de horas) e lógicos (TRUE ou FALSE, definido em função do tempo descansado1). Note a diferença entre dado e valor. O número 10 é um valor, sem significado. Por outro lado, “10 horas dormidas” é um dado, caracterizado pelo valor 10 e pela variável “horas dormidas”.\nOutro aspecto importante sobre os dados está em sua forma, ou seja, como os dados podem ser organizados. A Tabela 5.2 apresenta as formas mais comuns de organização.\n\n\n\n\nTabela 5.2: Formas pelas quais os dados podem ser organizados\n\n\n\n\n\n\n\n\n\n\n\nFormato\nOs dados se apresentam como…\nExemplo\n\n\n\n\nEscalar\nelementos individuais\n“AB”, 4, TRUE\n\n\nRetangular\ndados organizados em \\(i\\) linhas e \\(j\\) colunas\nVetores e Tabelas de Dados\n\n\nNão-retangular\njunção de uma ou mais estruturas de dados\nListas\n\n\n\n\n\n\n\n\nUm escalar é um elemento único, que pode ser de qualquer tipo. Ou seja, a representação elementar de um dado se dá através de um escalar! Por exemplo, o tipo sanguíneo de determinada pessoa, representado pelos caracteres “AB”, é um escalar do tipo texto. Você pode pensar no escalar como um dado organizado em 1 linha e 1 coluna.\nPor sua vez, dados retangulares são àqueles cuja organização ocorre em \\(i\\) linhas e \\(j\\) colunas, tal que \\(i,j \\in \\mathbb{N}\\) e \\(i &gt; 1\\) ou \\(j &gt; 1\\). As formas retangulares mais comuns são vetores, matrizes e tabelas de dados. Uma matriz é uma forma de organização de dados númericos em em \\(i\\) linhas e \\(j\\) colunas. Quando uma matriz possui \\(i\\) linhas e \\(1\\) coluna ou \\(1\\) linha e \\(j\\) colunas, chamamos de vetor-coluna e vetor-linha, respectivamente; na prática, chamamos ambos apenas de vetor. Assim, o vetor é um caso especial de matriz unidimensional. As tabelas de dados, por outro lado, possuem \\(i\\) linhas e \\(j\\) colunas, tal que \\(i &gt; 1\\) e \\(j &gt; 1\\). Além disso, aceitam todos os tipos de dado – por exemplo, númericos, de textos ou lógicos – em qualquer que seja a combinação de linha e coluna.\nPor sua vez, dados não-retangulares se referem a toda organização de dados que não seja feita em linhas e colunas relacionadas entre si. A forma mais comum é a lista. Observe um exemplo abaixo: cada característica pode ser entendida como um elemento de uma lista. Apesar de pertencerem a mesma estrutura, os elementos não se comunicam entre si.\n\n\n\n\n\n \n \n \n \n \n \n\n\n \nJorge\nLaís\nMatheus\nLaura\nNathália\n\n\nGênero\nMasculino\nFeminino\nMasculino\nFeminino\nFeminino\n\n\n \n \n \n \n \n \n\n\n \nJorge\nLaís\nMatheus\nLaura\nNathália\n\n\nIdade\n18\n23\n22\n21\n21\n\n\n \n \n \n \n \n \n\n\n \nJorge\nLaís\nMatheus\nLaura\nNathália\n\n\nAltura (cm)\n180\n170\n170\n175\n168\n\n\n \n \n \n \n \n \n\n\n \nJorge\nLaís\nMatheus\nLaura\nNathália\n\n\nPeso (kg)\n76\n65\n70\n68\n66\n\n\n \n \n \n \n \n \n\n\n\n\n\nNesse caso em específico, conseguimos fazer a transição para uma tabela (forma retangular) pois todos os elementos são são características das mesmas pessoas. Em uma tabela de dados, automaticamente temos uma relação entre os dados: cada linha contém características de uma unidade específica.\n\n\n\n\nTabela 5.3\n\n\n\n\n\n\nNome\nGênero\nIdade\nAltura (cm)\nPeso (kg)\n\n\n\n\nJorge\nMasculino\n18\n180\n76\n\n\nLaís\nFeminino\n23\n170\n65\n\n\nMatheus\nMasculino\n22\n175\n70\n\n\nLaura\nFeminino\n21\n181\n68\n\n\nNathália\nFeminino\n21\n168\n66",
    "crumbs": [
      "R Básico",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Objetos</span>"
    ]
  },
  {
    "objectID": "objetos.html#estruturas-de-dados-no-r",
    "href": "objetos.html#estruturas-de-dados-no-r",
    "title": "5  Objetos",
    "section": "5.2 Estruturas de Dados no R",
    "text": "5.2 Estruturas de Dados no R\nNa seção anterior, vimos os conceitos de tipo e forma. Tenha em mente que são duas definições que existem independentemente de qualquer linguagem de programação – elas versam sobre valores e dados de forma geral.\nPor outro lado, agora veremos o conceito e alguns exemplos de estrutura de dados para o R. A estrutura de dados é a forma pela qual o R classificará um objeto em relação ao tipo e a forma dos dados que contém. Existe uma estrutura de dados para cada combinação de tipo e forma? Não. Compreender as principais estruturas disponíveis no R requer vê-las como uma combinação de\n\nDeterminado formato de dados\nNúmero de tipos de dados (se é único ou possui vários)\n\n\n5.2.1 Criando e armazenando objetos na memória\nAntes de conhecê-las, no entanto, vamos entender melhor os comandos para criar e armazenar qualquer objeto (seja ele para armazenar dados, como nesse capítulo, ou para criar funções, que serão vistas no próximo) na memória do R.\nPara criar e armazenar um objeto, sempre escreveremos inicialmente seu nome (escolhido por você), seguido de um dos operadores de atribuição (ou assingment operators, como são conhecidos) e, por fim, o objeto propriamente dito com as informações de nosso interesse. O principal operador de atribuição para se criar objetos é &lt;-. Outro operador que é comumente utilizado para cumprir a mesma tarefa é =. Ainda que exista uma leve diferença entre ambos, ao longo dos cursos será possível utilizar o operador de sua preferência. Por ser o ideal, utilizaremos &lt;- no restante do material.\n\nnome_do_objeto &lt;- &gt;objeto com informações&lt;\n  \nnome do objeto =  &gt;objeto com informações&lt;\n\nNo parágrafo anterior, observe que está escrito ‘criar e armazenar’. Nós poderíamos simplesmente criar um objeto, sem armazená-lo na memória do R. Nesse caso, não teríamos o nome do objeto disponível na aba Environment (ou seja, ele não seria armazenado no nosso ambiente de trabalho) e seria bem mais complicado registrar todas as mudanças que viermos a fazer nele. Aconteceria apenas a ocorrência de uma única saída no Console com a estrutura do objeto criado (de forma semelhante ao que fizemos no capítulo anterior) – o quê não tem grande utilidade para nós, exceto caso você queira verificar a estrutura do objeto antes de realmente armazená-lo.\nAo mesmo tempo, você irá perceber que a criação e armazenamento de um objeto não implica sua visualização imediata. Isso signfinica que, ao dar o comando para criar algum objeto, não acontecerá nada no Console. Você pode acabar achando que o processo falhou ou algo do tipo, mas não é nada disso! Como dissemos, a mudança ocorrerá na aba Environment, onde deverá aparecer o nome do novo objeto. Para visualizar o objeto criado, escreva seu nome e rode a linha de código. Agora sim o objeto aparecerá no Console.\n\nnome_do_objeto\n\nSe você criou e armazenou um objeto na memória, ele ficará por lá até que você encerre sua sessão atual (feche o RStudio) ou, então, que o remova. Para remover qualquer objeto basta escrever rm(nome_do_objeto). Caso tenha o desejo de remover vários objetos, basta separar seus nomes com vírgula. Para remover todos os objetos que aparecem na aba Environment, use rm(list = ls()).\n\nrm(nome_do_objeto1)\n\nrm(nome_do_objeto1, nome_do_objeto2, ...)\n\nrm(list = ls())\n\nObserve no GIF abaixo como é na prática!\n\n\n\n\n\n\n\n5.2.2 Valor único\nAo criar um objeto com valor único, estamos armazenando um escalar que pode variar quanto ao tipo (por exemplo, númerico, string ou valor lógico). Nesse caso, a estrutura do objeto será idêntica ao tipo – o que faz sentido, afinal estamos falando de um objeto de uma única linha e coluna.\n\n5.2.2.1 Numérico\nUm objeto númerico contém apenas um número (por exemplo, 1, 2, 4.13, \\(\\pi\\), entre outros). Se quisessemos atribuir o valor numérico 5 à um objeto chamado x, como poderiamos fazer? Observe abaixo e replique no seu RStudio!\n\nx &lt;- 5 \n\nNote que o Console não retorna nenhuma mensagem ou valor. Como dissemos na seção anterior, a única diferença que você deve ser capaz de observar é no painel Environment, no quadrante superior direito do RStudio. O nome do novo objeto aparecerá lá. Para que você possa visualizar o conteúdo do objeto criado, terá que escrever apenas seu nome e rodar a linha de código!\n\nx\n\n[1] 5\n\n\n\n\n5.2.2.2 Textual\nUma sequência de caracteres (character string, ou apenas string) é um conjunto de caracteres dentro de um par de aspas e pode ou não incluir espaços. Por exemplo, “elevada” e “pressão arterial elevada” são objetos de caracteres com um único valor de string.\n\ny &lt;- \"pressão arterial elevada\" \ny\n\n[1] \"pressão arterial elevada\"\n\n\n\n\n\n5.2.3 Vetor\nUm vetor contém uma coleção ordenada de dados indexados pelos inteiros \\(1, 2,..., n\\), onde \\(n\\) é o comprimento do vetor. O vetor como estrutura de dados é a combinação da forma vetor com dados de um único tipo, não necessariamente numérico. No exemplo abaixo, um vetor númerico, isto é, que contém apenas números.\n\nz &lt;- c(5, 8, 12) \nz\n\n[1]  5  8 12\n\n\nSe você tentar criar um vetor contendo dois tipos de dados diferentes, ele converterá todos os dados para o tipo texto. No exemplo abaixo, o vetor z é armazenado como vetor do tipo texto, mesmo que o criemos contendo inicialmente o número 5 e o tipo lógico NA (Not Available).\n\nz &lt;- c(5, \"texto\", TRUE, NA)\nz\n\n[1] \"5\"     \"texto\" \"TRUE\"  NA     \n\n\n\n\n\n\n\n\nNA (Not Avaiable)\n\n\n\nEm determinadas situações, não teremos dados para algumas observações. Imagine, por exemplo, uma pesquisa domiciliar: nem todas as pessoas podem responder as perguntar feitas pelo avaliador. Ao mesmo tempo, não seria adequado descartar o restante das informações coletadas. Como, então, indicar que determinado dado não existe?\nNo R, utilizaremos o valor NA para representar dados faltantes. O tipo padrão de NA é lógico, a menos que seja forçado a algum outro tipo, como no caso do vetor do exemplo anterior, onde se tornou do tipo texto (mesmo que na saída não esteja cercado por aspas). Existem vários tipos de valores NA!\n\n\nÉ inegável que, a partir deste ponto, as estruturas começam a ficar mais interessantes. Lembre-se que o vetor tem uma dimensão e pode ter muitas informações armazenadas. É natural que, em determinadas situações, desejemos acessar apenas valores específicos dentre os que constam nele.\nComo podemos fazer isso? Note que podemos um número associar a cada elemento de um vetor, representando a linha ou coluna em que consta. A esse número chamamos de índice. Dessa forma, fica fácil acessar qualquer um de seus valores: basta escrever, ao lado de seu nome e entre colchetes, o índice que está associado à este valor. Por exemplo, vamos acessar o segundo elemento do vetor z que acabamos de criar.\n\nz[2] # Acessando o segundo elemento do vetor z\n\n[1] \"texto\"\n\n\nVocê também acessar mais de um valor específico.\n\nz[2:4] # Acessando do segundo ao quarto elemento do vetor z\n\n[1] \"texto\" \"TRUE\"  NA     \n\n\n\n\n\n\n\n\nAlgumas formas de criar vetores padronizados\n\n\n\nEm determinadas situações, você pode ter o desejo de criar um vetor que tenha certo padrão. Por exemplo, se quiséssemos criar um vetor contendo todos os números inteiros de 1 a 7, como faríamos? Uma opção, de fato, é escrever c(1,2,3,4,5,6,7). No entanto, essa abordagem não é prática quando a sequência for grande: imagine ter que escrever todos os inteiros de 1 a 100, por exemplo! Nessas ocasiões, podemos gerar o vetor desejado escrevendo os limites inferior e superior separados pelo operador :!\n\n2:10                # Criando uma sequência de números de 2 a 10\n\n[1]  2  3  4  5  6  7  8  9 10\n\n\nMas… e se quiséssemos selecionar uma sequência com mesmo intervalo, de tal maneira que o termo seguinte fosse igual ao termo anterior mais dois? Podemos usar a função seq()! Note que, tanto neste caso quanto no anterior, estamos falando da criação de vetores numéricos.\n\nseq(2, 10, by = 2) # Criando um sequência de 2 a 10 pulando um número.\n\n[1]  2  4  6  8 10\n\n\nPor fim, e não menos importante, você ter o desejo de criar um vetor com valores repetidos – seja número, texto ou lógico. Para essa tarefa, utilizamos a função rep()!\n\nrep(3, 5)          # Repetindo o número 3, 5 vezes \n\n[1] 3 3 3 3 3\n\nrep(c(1,\"ab\"), 3)  # Repetindo o vetor (1,\"ab\"), 3 vezes\n\n[1] \"1\"  \"ab\" \"1\"  \"ab\" \"1\"  \"ab\"\n\n\n\n\n\n5.2.3.1 Fator\nUm fator é um tipo especial de vetor que contém valores numéricos subjacentes \\(1, 2,..., n\\), mas cada um desses \\(n\\) valores possui um rótulo de texto associado (que pode ou não ser o valor numérico). Esses valores rotulados são os níveis (levels) do fator. Um uso comum de um fator é armazenar uma variável categórica. Depois de criar um vetor de fator com níveis específicos, nenhum elemento desse vetor poderá assumir um valor que não seja um de seus níveis pré-atribuídos.\nVocê pode criar um fator a partir de um vetor de caracteres e o R assumirá que os valores únicos são os rótulos dos níveis. Por exemplo, no exemplo abaixo os níveis serão “lento”, “normal” e “rápido”.\n\ny &lt;- factor(c(\"super rápido\", \"super lento\", \"normal\", \"super rápido\", \"normal\"))\ny         # Rodar o vetor de fator também irá retornar os níveis\n\n[1] super rápido super lento  normal       super rápido normal      \nLevels: normal super lento super rápido\n\n\nSe quiser alterar os rótulos, você pode fazê-lo atribuindo um novo valor aos seus níveis. Por exemplo, suponha que queiramos que os rótulos sejam maiúsculos.\n\nlevels(y) &lt;- c(\"Super Rápido\", \"Normal\", \"Super Lento\") \nlevels(y)\n\n[1] \"Super Rápido\" \"Normal\"       \"Super Lento\" \n\n\nComo alternativa, você pode atribuir novos rótulos de nível ao criar o fator. Isso tem a vantagem adicional de permitir que você decida em que ordem os níveis devem aparecer. Quando criamos o fator, R atribuiu automaticamente os níveis pegando os valores exclusivos de y e colocando-os em ordem alfabética. Por vários motivos (como criar um gráfico de barras posteriormente), você pode querer que os níveis estejam em uma ordem diferente. Você pode especificar a ordem dos níveis ao criar a variável, mas tome cuidado porque se você deixar de fora um valor que aparece nos dados esse valor acabará definido como ausente (NA).\nNo exemplo anterior, gostaríamos que a ordem fosse da velocidade menor para o maior.\n\n# Insira os valores originais nos níveis\n# Insira os novos valores nos rótulos\n# Tenha certeza que a ordem dos níveis e dos rótulos correspondem \n\ny &lt;- factor(c(\"super rápido\", \"super lento\", \"normal\", \"super rápido\", \"normal\"),              \n            levels = c(\"super lento\", \"normal\", \"super rápido\"), \n            labels = c(\"Super Lento\", \"Normal\", \"Super Rápido\")) \nlevels(y)\n\n[1] \"Super Lento\"  \"Normal\"       \"Super Rápido\"\n\ny\n\n[1] Super Rápido Super Lento  Normal       Super Rápido Normal      \nLevels: Super Lento Normal Super Rápido\n\n\n\n\n\n5.2.4 Matriz\nUma matriz contém uma coleção bidimensional de dados indexados por pares de inteiros \\((i, j)\\). A matriz como estrutura de dados é a combinação da forma matriz com dados de um único tipo, não necessariamente numérico. Abaixo, uma matriz numérica.\n\nx &lt;- matrix(c(1,2,3,4,5,6), nrow = 2, ncol = 3) \nx\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n\nAssim como os vetores, as matrizes não podem conter valores de diferentes tipos. Se você tentar criar uma matriz contendo valores numéricos e de caracteres, por exemplo, ela converterá os valores numéricos em caracteres. Note que você pode definir o número de linhas e colunas que uma matriz venha a possuir.\n\nz &lt;- matrix(c(1,2,\"c\",\"d\",\"e\",\"f\"), nrow = 3, ncol = 2) \nz\n\n     [,1] [,2]\n[1,] \"1\"  \"d\" \n[2,] \"2\"  \"e\" \n[3,] \"c\"  \"f\" \n\nz &lt;- matrix(c(1,2,\"c\",\"d\",\"e\",\"f\"), nrow = 2, ncol = 3) \nz\n\n     [,1] [,2] [,3]\n[1,] \"1\"  \"c\"  \"e\" \n[2,] \"2\"  \"d\"  \"f\" \n\n\nÉ importante ressaltar que, no R, uma matriz criada com \\(i\\) linhas e \\(1\\) coluna (ou \\(1\\) linha e \\(j\\) colunas) continua sendo interpretada como uma matriz, ao invés de ser interpretada como vetor-coluna (ou vetor-linha).\nComo a matriz é um objeto de natureza bidimensional, podemos acessar seus elementos individuais através da inserção dos seus índices de linha e coluna. Por exemplo, para acessar o elemento presente na segunda linha e terceira coluna da matriz z que aramazenamos por último, rode:\n\nz[2,3]\n\n[1] \"f\"\n\n\nOutra forma de acessar algum dado específico da matriz é pensá-la como sendo um único vetor, o qual vai sendo repartido conforme termina o tamanho que você pré-selecionou paras colunas. Dessa forma, podemos retornar determinado elemento pensando em seu índice de vetor. Por exemplo, poderíamos acessar o dado f pensando que é o sexto elemento do equivalente ao vetor c(\"a\",\"b\",\"c\",\"d\",\"e\",\"f\").\n\nz[6]\n\n[1] \"f\"\n\n\nAo mesmo tempo, podemos acessar apenas uma coluna ou linha específica. Para tal, selecione a coluna ou linha que deseja retornar e deixe a coordenada restante como espaço vazio. No código abaixo, vamos selecionar inicialmente a primeira linha da matriz z e, na sequência, sua terceira coluna.\n\nz[1,]\n\n[1] \"1\" \"c\" \"e\"\n\nz[,3]\n\n[1] \"e\" \"f\"\n\n\n\n\n5.2.5 Data frame\nComo matrizes (e vetores) contêm dados de apenas um tipo (por exemplo, todas as células são dados numéricos, de caracteres ou lógicos), precisamos de outra estrutura de dados para dados heterogêneos.\nA necessidade de armazenar dados heterogêneos não é nada exótico ou incomum. Na verdade, mesmo os conjuntos de dados mais simples exigem a mistura de vários tipos de dados. Por exemplo, imagine que queremos armazenar um conjunto de dados que contém informações básicas sobre um grupo de pessoas, assim como na Tabela 5.3. Cada uma dessas cinco variáveis pode ser armazenada como um vetor (as duas primeiras do tipo caractere, as outras do tipo numérico). Para armazenar todas as cinco variáveis em uma única estrutura de dados, podemos combinar os cinco vetores em uma tabela retangular. As tabelas são a forma mais frequente de armazenar dados!\nE qual o nome da estrutura de dados que armazena tabelas de dados no R? São os data frames! O data frame como estrutura de dados é a combinação da forma tabela e da presença de qualquer tipo de dado. No chunk abaixo, vamos recriar a Tabela 5.3 como exemplo.\n\ninfo_pessoas &lt;- data.frame(Nome = c(\"Jorge\", \"Laís\", \"Matheus\", \"Laura\", \"Nathália\"),\n                           Gênero = c(\"Masculino\", \"Feminino\", \"Masculino\", \"Feminino\", \"Feminino\"),\n                           Idade = c(18, 23, 22, 21, 21),\n                           Altura = c(180, 170, 175, 181, 168),\n                           Peso = c(76, 65, 70, 68, 66))\n\ninfo_pessoas\n\n      Nome    Gênero Idade Altura Peso\n1    Jorge Masculino    18    180   76\n2     Laís  Feminino    23    170   65\n3  Matheus Masculino    22    175   70\n4    Laura  Feminino    21    181   68\n5 Nathália  Feminino    21    168   66\n\n\nVocê pode acessar qualquer dado específico de um data frame a partir do mesmo procedimento utilizado com matrizes. Por exemplo, para acessar o dado contido na segunda linha da primeira coluna, basta rodar info_pessoas[2,1].\n\ninfo_pessoas[2,1]\n\n[1] \"Laís\"\n\n\nDe forma semelhante, podemos acessar uma coluna ou linha específica.\n\ninfo_pessoas[,2] # Retornando dados da segundo coluna\n\n[1] \"Masculino\" \"Feminino\"  \"Masculino\" \"Feminino\"  \"Feminino\" \n\n\n\ninfo_pessoas[1,] # Retornando dados da primeira linha\n\n   Nome    Gênero Idade Altura Peso\n1 Jorge Masculino    18    180   76\n\n\nÉ interessante notar que um data frame pode ser pensado como a junção de múltiplos vetores-coluna, cada um representando determinada variável! Isso nos dá outra forma de selecionar colunas específicas: basta colocar entre colchetes o índice do vetor-coluna que você deseja selecionar. Note, no entanto, uma diferença: nesta sintaxe, o objeto que retornará ainda terá estrutura de um data frame (agora com cinco linhas e uma coluna) ao invés de vetor, como no chunk anterior.\n\ninfo_pessoas[2]\n\n     Gênero\n1 Masculino\n2  Feminino\n3 Masculino\n4  Feminino\n5  Feminino\n\n\n\n\n5.2.6 Lista\nUma lista contém uma coleção ordenada de objetos, sendo que estes podem ser de tipos diferentes. A lista como estrutura de dados é a combinação da forma lista (representando dados não-retangulares) e da presença de qualquer tipo de dado. Na prática, uma lista pode aceitar qualquer objeto de dados como elemento – inclusive uma outra lista!\nPara que fique mais claro, abaixo está uma lista que contém um objeto com cada tipo de estrutura vista até agora! Colocamos nesta lista um valor único, um vetor, uma matriz e um data frame. Eles serão armazenados em um novo objeto, que nomeamos de lista_exemplo.\n\nlista_exemplo &lt;- list(\"5\", c(1,2,3), matrix(c(2,2,3,4), 2, 2), info_pessoas)\n\nObserve que a lista, apesar de poder contar com objetos de várias estruturas (e, consequentemente, dimensões), acaba por ter uma única dimensão. Você pode acessar seus elementos de forma parecida com o caso de um vetor. A diferença é que, no caso de uma lista, teremos que utilizar duplo colchetes. Abaixo, um exemplo de como acessar o quarto elemento da lista_exemplo – no caso, o data frame info_pessoas que criamos anteriormente.\n\nlista_exemplo[[4]]\n\n      Nome    Gênero Idade Altura Peso\n1    Jorge Masculino    18    180   76\n2     Laís  Feminino    23    170   65\n3  Matheus Masculino    22    175   70\n4    Laura  Feminino    21    181   68\n5 Nathália  Feminino    21    168   66\n\n\nListas são mais úteis do que você pode estar pensando nesse momento. Elas permitem que você agrupe objetos de um mesmo assunto, mas com diferentes estruturas, em um único objeto ‘central’. Em muitos casos, facilita a organização.",
    "crumbs": [
      "R Básico",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Objetos</span>"
    ]
  },
  {
    "objectID": "objetos.html#footnotes",
    "href": "objetos.html#footnotes",
    "title": "5  Objetos",
    "section": "",
    "text": "Se o número de horas que a pessoa descansou for maior do que 8, então a variável deverá apresentar valor igual a TRUE – ou seja, é verdade que a pessoa dormiu mais de 8 horas. Caso contrário, FALSE.↩︎",
    "crumbs": [
      "R Básico",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Objetos</span>"
    ]
  },
  {
    "objectID": "funcoes-e-pacotes.html",
    "href": "funcoes-e-pacotes.html",
    "title": "6  Funções e pacotes",
    "section": "",
    "text": "6.1 O que é uma função?\nAntes, vamos pensar em funções no contexto matemático. Segundo Stewart (2015),\nEm que o conjunto \\(A\\) chamamos de domínio, compreendendo todos os valores que a função pode aceitar, ao passo que o conjunto \\(B\\) é conhecido como imagem, compreendendo todos valores que a função consegue retornar. Podemos representar uma função de quatro formas diferentes:\nVamos deixar os conceitos mais claros. Imagine que te propronho a seguinte regra: dividirei o número 2 por todos os números possíveis. Observe que, nesse exemplo, os números possíveis são todos exceto zero – afinal de contas, qualquer número dividido por zero resulta em uma indefinição matemática. Podemos dizer, portanto, que o domínio da nossa função é dado por todos os números reais exceto zero. Ao mesmo tempo, quais valores podem surgir como resultado dessa nossa regrinha? Novamente, todos os reais exceto zero – afinal, nenhum número que utilizemos será tão grande em valor absoluto tal que a divisão resulte em zero, ao passo que qualquer valor extremo (tanto negativo, quanto positivo) pode ser alcançado plugando na função valores menores do que um em módulo1! Portanto, nesse caso, a imagem da nossa função é idêntica ao domínio.\nPerceba que definimos a função acima de modo verbal, ou seja, com palavras. Poderíamos também descrevê-la numericamente através de uma tabela ou, então, de forma visual com um gráfico (ambas abaixo). De todo modo, a forma mais comum de se descrever uma função é através de sua fórmula que, no nosso exemplo, seria \\(f(x)=2/x\\).\nNão precisamos nos aprofundar nos conceitos. O que você precisa guardar dessa seção é o fato de podermos pensar na função como uma caixa preta que, ao receber elementos de \\(A\\), os transforma em um determinado valor (output) presente em \\(B\\). Como vimos, a forma pela qual essa ‘caixa preta’ irá transformar \\(x\\) em \\(f(x)\\) é a nossa regra propriamente dita.",
    "crumbs": [
      "R Básico",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Funções e pacotes</span>"
    ]
  },
  {
    "objectID": "funcoes-e-pacotes.html#o-que-é-uma-função",
    "href": "funcoes-e-pacotes.html#o-que-é-uma-função",
    "title": "6  Funções e pacotes",
    "section": "",
    "text": "Uma função é uma regra que atribui, para cada elemento \\(x\\) em um conjunto \\(A\\), exatamente um elemento, chamado \\(f(x)\\), em um conjunto \\(B\\).\n\n\n\nVerbalmente (através de palavras);\nNumericamente (através uma tabela de dados);\nVisualmente (através de um gráfico);\nAlgebricamente (através de uma fórmula)\n\n\n\n\n\n\n\n\n\n\n\\(x\\)\n\\(f(x)\\)\n\n\n\n\n-3\n-0.67\n\n\n-2\n-1.00\n\n\n-1\n-2.00\n\n\n1\n2.00\n\n\n2\n1.00\n\n\n3\n0.67",
    "crumbs": [
      "R Básico",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Funções e pacotes</span>"
    ]
  },
  {
    "objectID": "funcoes-e-pacotes.html#o-que-é-uma-função-para-o-r",
    "href": "funcoes-e-pacotes.html#o-que-é-uma-função-para-o-r",
    "title": "6  Funções e pacotes",
    "section": "6.2 O que é uma função para o R?",
    "text": "6.2 O que é uma função para o R?\nE por quê essa historinha toda sobre funções matemáticas nos interessa? Simplesmente pois podemos traçar um paralelo com o conceito de função para a linguagem R! No R, uma função é um objeto que recebe argumentos (inputs) e executa uma ação sobre ou a partir deles, de acordo com o bloco de código nela embutido, te devolvendo um determinado resultado (output). A lógica é a mesma de uma função matemática! O nome não é por acaso.\n\n\n\n\n\nflowchart LR\n  A(Input 1) --&gt; D[\"Caixa Preta \\n (Função)\"]\n  B(Input 2) --&gt; D[\"Caixa Preta \\n (Função)\"]\n  C(Input N) --&gt; D[\"Caixa Preta \\n (Função)\"]\n  D --&gt; E[Output]\n\n\n\n\n\n\nDe certa forma, continuamos a ter um domínio, pois cada função atende um número específico de estruturas de objeto e/ou tipos de variável – algumas funções podem aceitar apenas vetores como argumento, por exemplo, enquanto outras podem ser específicas para variavéis númericas. Ao mesmo tempo, continuamos a ter uma imagem, associada aos resultados possíveis. E qual é o equivalente à regra? É o bloco de código embutido na função!\n\n6.2.1 Vantagens\nNas seções anteriores, compreendemos um pouco melhor como funciona o mecanismo de uma função. Mas ainda pode haver dúvida do tipo: “Beleza, mas em qual contexto prático que ela será útil?”\nO grande benefício de uma função se constitui no fato de seu bloco de código interior, condicionado ao valor dos argumentos, realizar sempre a mesma tarefa quando a rodamos! Isso significa que as funções permitem automatizar tarefas comuns de uma forma mais legível, evitando a prática de ‘copiar e colar’ repetidamente as mesmas linhas de código, que serão substituídas pelo nome da função e seus argumentos. Na prática, além da melhor compreensão do código, eliminamos a chance de cometer erros bobos ao copiar e colar (por exemplo, acabar atualizando o nome de uma variável em um lugar, mas não em outro) e tornamos mais fácil reutilizar o trabalho que foi escrito em outros projetos, aumentando a produtividade.\n\n\n6.2.2 Criando\nA sintaxe para criar uma função é a seguinte:\n\nnome_da_funcao &lt;- function(arg1 = default1, ..., argn = defaultn) {\n  &gt;bloco de código&lt;\n}\n\nPerceba que o uso o operador &lt;- nos mostra que, ao criar uma função, estamos criando um objeto – que, nesse caso, não é designado especificamente a armazenar dados. Entre parentêses, definimos o nome dos argumentos e, caso necessário, seus respectivos valores de default. Na sequência, entre chaves, escrevemos o bloco de código que rodará sobre os inputs. Como exemplo, vamos criar a função soma2.\n\nsoma2 &lt;- function(somando1, somando2) {\n  (somando1 + somando2) ^ 2\n}\n\nO que ela faz? Soma dois números e eleva esse resultado intermediário ao quadrado. A função criada poderá ser vista no quadrante superior direito, no painel Environment.\n\n\n6.2.3 Utilizando\nPor sua vez, a sintaxe para usar uma função é:\n\nnome_da_funcao(arg1, ..., argn)\n\nEm primeiro lugar, é necessário escrever o nome da função no Editor de Código. Ao lado, entre parênteses, escreveremos seus argumentos – no exemplo acima, arg1, arg2 até argn; uma função pode ser construída de modo a ter qualquer número n de argumentos e eles serão sempre separados por vírgula. Esses argumentos são os nossos inputs. Por fim, rodamos a linha em que a escrevemos, fazendo com que seja executada pelo R e seu resultado apareça no Console.\n\n\n\n\n\n\nExemplo 1\n\n\n\nVamos tomar como exemplo a função sum(). O que ela faz? Segundo sua documentação:\n\nsum retorna a soma de todos os valores presentes em seus argumentos\n\nNa prática, como o nome já nos indica, ela tem como serventia somar todos os números que lhe forem passados. Se quisessemos utilizá-la para obter o resultado da soma dos números 4, 7 e 9, como faríamos? Se você pensou em sum(4, 7, 9), acertou!\n\nsum(4, 7, 9)\n\n[1] 20\n\n\nPerceba que utilizamos três argumentos, um para cada número que somamos: 4, 7 e 9 estão associados a arg1, arg2 e arg3, respectivamente. No entanto, dado que a função sum() aceita objetos como vetores, matrizes e dataframes, poderíamos ter utilizado apenas um único argumento!\n\nsum(c(4, 7, 9))\n\n[1] 20\n\nsum(matrix(c(4, 7, 9)))\n\n[1] 20\n\nsum(data.frame(c(4, 7, 9)))\n\n[1] 20\n\n\nNo chunk acima, c(4, 7, 9), matrix(c(4, 7, 9)) e data.frame(c(4, 7, 9)) estão associados apenas ao arg1! Em muitos casos, entender os tipos de objetos aceitos pela função será importante para a eficiência do código. Imagine que estivessemos com interesse de somar todos os valores de uma certa coluna em determinado dataframe. Como poderíamos realizar essa tarefa? Dado que cada coluna de um dataframe é simplesmente um vetor, poderíamos inserí-la diretamente na função, como um único argumento!\n\ndf1 = data.frame(x = c(4, 7, 9))\nsum(df1$x)\n\n[1] 20\n\n\nLembre-se de ficar atento com relação à estrutura e/ou tipo de variável que determinada função pode aceitar. Será que se trocassemos o número 4 por “4”, a função ainda rodaria? A respota é não, afinal de contas “4” é interpretado como texto, e não como número (e você não consegue somar textos)!\n\nsum(c(\"4\", 7, 9))\nError in sum(df1$x) : 'type' inválido (character) do argumento\n\n\n\nEm muitas situações, teremos argumentos nomeados. Isto ocorre pois nem todo argumento será processado da mesma forma pelo código embutido na função. Também é muito comum que certos argumentos tenham um valor pré-determinado como default, isto é, caso você não especifique algum valor para aquele argumento, o valor de default será utilizado.\n\n\n\n\n\n\nExemplo 2\n\n\n\nNesse caso, vamos tomar como exemplo a função paste(). Qual seu papel?\n\nConcatenar vetores após converter em caractere\n\nPortanto, a função paste irá transformar os vetores que introduzirmos em vetores com dados do tipo character e, na sequência, irá juntá-los. Na prática, serve para juntar palavras e/ou caracteres que estão inicialmente separados em uma única variável do tipo texto. Por exemplo, podemos estar dispostos a juntar as palavras “Estou”, “apredendendo” e “a usar o R” em um único vetor.\n\npaste(\"Estou\", \"aprendendo\", \"a usar o R\")\n\n[1] \"Estou aprendendo a usar o R\"\n\n\nNote que o caractere default (padrão) utilizado para separar as palavras é o espaço em branco! E se quisessemos separá-las por vírgula? Nesse caso, teríamos que especificar o argumento sep com esse delimitador!\n\npaste(\"Estou\", \"aprendendo\", \"a usar o R\", sep = \",\")\n\n[1] \"Estou,aprendendo,a usar o R\"\n\n\n\n\nPor fim note que, mesmo sem você saber, já utilizamos funções nos últimos capítulos!\n\nc(): função utilizada para criar um vetor;\nmatrix(): para criar uma matriz;\ndata.frame(): para criar um data frame;\nlist(): para criar uma lista.\n\nTodas essas funções utilizavam como argumento principal os dados que tínhamos interesse e, através de seu código embutido, criavam e armazenavam o objeto na memória do R!\n\n\n\n\n\n\nOperadores são funções! (Opcional)\n\n\n\n\n\nSim, é isso mesmo que você leu! Lembre-se das nossas máximas: tudo que existe no R é um objeto e tudo que acontece é uma execução de função. É algo simples e direto ver que operadores como + , : e &lt;- existem na linguagem – não à toa estão sendo mencionados. Mas perceba que eles também criam, armazenam ou transformam objetos! Por exemplo, o operador + transforma 1+1 em 2! Pense nos operadores como um tipo especial de função de dois argumentos, o primeiro posicionado à esquerda e o segundo à direita.\n“Mas uma função não deveria ser escrita como nome_da_funcao(arg1, ..., argn)?“ Você pode escrevê-los dessa forma também! Só não será tão útil.\n\n`+`(1, 3)     # O mesmo que 1 + 3\n\n[1] 4\n\n`:`(1, 10)    # 1:10\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n`&lt;-`(x, 10)   # x &lt;- 10\n\n\n\n\n\n\n\n\n\n\nFunções no Excel (Opcional)\n\n\n\n\n\nSe você já usou o Microsoft Excel em algum momento da sua vida, com certeza já teve contato com o alguma função! Por exemplo, lá temos a função =SOMA(), que realiza a mesma tarefa da função sum() no R! Inclusive, também é possível criar funções no Excel através de sua linguagem de programação própria, o Visual Basic for Applications (VBA).",
    "crumbs": [
      "R Básico",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Funções e pacotes</span>"
    ]
  },
  {
    "objectID": "funcoes-e-pacotes.html#pacotes",
    "href": "funcoes-e-pacotes.html#pacotes",
    "title": "6  Funções e pacotes",
    "section": "6.3 Pacotes",
    "text": "6.3 Pacotes\nChamamos de pacote um conjunto de dados e/ou funções, acompanhadas de suas respectivas documentações, que foram criadas e disponibilizadas por alguma pessoa. Existem pacotes padrão (ou básicos) que são considerados parte do código-fonte do R e estão automaticamente disponíveis como parte da instalação do R (ou seja, foram criados pelos desenvolvedores da linguagem). No entanto, definitivamente não são a maioria: o grosso dos pacotes disponíveis é de autoria dos membros da comunidade. Normalmente, as funções que integram um pacote estão relacionadas à determinado tema, ainda que isso não seja obrigatório.\nPor exemplo, suponha que criemos quatro funções que antes não existiam na linguagem: soma(), subtração(), multiplicacao() e divisao(), representando as quatro operações aritméticas básicas. Como estão relacionadas à um mesmo tema, poderiamos agrupá-las em um pacote chamado aritmetica e, na sequência, disponibilizá-lo em algum repositório para que outros usuários da linguagem pudessem baixá-lo. As pessoas que instalassem e carregassem nosso pacote teriam acesso às quatro funções acima, sem necessidade de ter que criá-las do zero! Ao mesmo tempo, o autor poderia adicionar um dataframe ao pacote, com intuito de possibilitar que você teste as funções que ele criou2.\nPerceba que, quando alguém cria uma função ou disponibiliza dados através de um pacote, fica complicado compreender inicialmente todas as características que esses objetos possuem. Por exemplo: ainda que os nomes sejam sugestivos, você saberia dizer com precisão o comportamento das quatro funções do pacote que criamos? Quais os tipos de objeto e variável que elas aceitam? Quais e quantos argumentos cada uma aceita? Provavelmente não. Para responder à todas essas perguntas, os autores disponibilizam uma documentação para cada objeto do pacote! Para acessá-la, basta rodar o nome da função/conjunto de dados acrescido de ? no início. O texto irá aparecer no quadrante inferior direito do RStudio, no painel Help3.\n\n6.3.1 Instalando\nA maneira mais comum de se baixar e instalar um pacote é através do CRAN! O mesmo local em que baixamos o R também atua como um repositório centralizado de pacotes. Mas fique tranquilo: você não precisará acessar o site novamente! Para baixar e instalar um pacote que está no CRAN, utilizaremos a função install.packages(), pertencente ao pacote utils (que é um pacote básico). Basta rodar install.packages(\"nome_do_pacote\"). No exemplo abaixo, a instalação do pacote readr.\n\ninstall.packages(\"readr\")\n\nRealizada a instalação com sucesso, já passa a ser possível utilizar suas funções/dados. Nesse momento, você deverá escrever o nome do pacote acrescido de :: e, na sequência, o nome da função/dado.\n\nreadr::read_csv(...)\n\n\n\n6.3.2 Carregando\n“Mas será sempre necessário escrever o nome do pacote antes da função?” Não. Perceba que os objetos oriundos de pacotes básicos podem ser executados diretamente. Isso ocorre pois eles são automaticamente carregados na sua sessão atual.\nResumindo: mesmo que você tenha instalado um pacote externo com sucesso, para usar seus objetos diretamente (sem precisar escrever seu nome antes) é necessário carregá-lo na sessão atual. Para carregar um pacote, rode a função library() acrescida do nome do pacote, sem aspas.\n\nlibrary(readr)\n\nAgora, é possível executar o objeto sem precisar escrever o nome do pacote antes.\n\nread_csv(...)\n\nA prática de carregar pacotes é a mais utilizada. Em outras palavras: sempre que instalarmos algum pacote, na sequência iremos carregá-lo na sessão atual para que possamos utilizar seus objetos de forma direta.",
    "crumbs": [
      "R Básico",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Funções e pacotes</span>"
    ]
  },
  {
    "objectID": "funcoes-e-pacotes.html#operador-pipe",
    "href": "funcoes-e-pacotes.html#operador-pipe",
    "title": "6  Funções e pacotes",
    "section": "6.4 Operador Pipe %>%",
    "text": "6.4 Operador Pipe %&gt;%\nNem sempre conseguiremos atingir o resultado que queremos utilizando apenas uma função. Por esse motivo, em muitas situações utilizaremos o resultado de uma função como argumento de outra função.\nPor exemplo, suponha que você queira somar dois números e, na sequência, comparar este resultado intermediário com 5 e 9, de modo a retornar o valor máximo entre os três números. Observe que a função sum() não é suficiente para realizar tal tarefa de modo completo: você até conseguirá somar dois números quaisquer, mas não será capaz de posteriormente comparar o resultado com o restante para saber qual é o valor máximo entre eles. Nesse caso, poderíamos então utilizar o resultado da função sum() como argumento da função max()!\n\nmax(sum(4, 3), 5, 9)\n\n[1] 9\n\n\nO R sempre executará as funções interiores primeiro. Ou seja, primeiro executa sum(4,3), retornando 7, e na sequência executa max(7, 5, 9), cujo resultado será 9, dado que este é o maior dentre os três números utilizados como argumento.\nO problema com esse tipo de sintaxe é que, conforme aproveitamos os resultados anteriores de outra função como argumento para as seguintes, mais confuso o código fica. Imagine se o número 4 também fosse resultado de alguma outra função: o código estaria bem mais difícil de entender!\n\nmax(sum(outra_funcao(...), 3), 5, 9)\n\nCom a finalidade de simplificar situações desse tipo, criou-se o operador Pipe, representado por %&gt;%. Este operador permite com que o resultado da função anterior se torne, implicitamente, o primeiro argumento da função seguinte! Poderíamos então reescrever nosso exemplo para:\n\nsum(4,3) %&gt;% max(5, 9)\n\n[1] 9\n\n\nO que o código acima nos diz é que sum(4,3) será interpretado como o primeiro argumento da função max(); automaticamente, 5 e 9 se tornam o segundo e o terceiro argumentos, respectivamente.\nPara utilizar o operador Pipe, antes é necessário instalar e carregar o pacote magrittr:\n\ninstall.packages(\"magrittr\")\nlibrary(magrittr)\n\nNa sequência, aperte Ctrl + Shift + M no Editor ou Console.\n\n6.4.1 Pipe nativo\nO uso do operador Pipe se tornou tão poopular que os desenvolvedores do R resolveram incorporar uma versão própria que já vem pré-instalada, conhecida como Pipe nativo (native Pipe). Ele exerce o mesmo papel principal (organização de código, como demonstrado na seção anterior) mas deixa a desejar em outras partes. A única vantagem é não precisar instalar e carregar um pacote. Portanto, recomendamos ainda o uso do Pipe ‘original’.\nDe todo modo, caso você queira utilizá-lo, basta substituir %&gt;% por |&gt;. Para continuar usando o atalho Ctrl + Shift + M, vá em Tools &gt; Global Options &gt; Code e marque Use native pipe operator.",
    "crumbs": [
      "R Básico",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Funções e pacotes</span>"
    ]
  },
  {
    "objectID": "funcoes-e-pacotes.html#footnotes",
    "href": "funcoes-e-pacotes.html#footnotes",
    "title": "6  Funções e pacotes",
    "section": "",
    "text": "Pense em números como \\(0,01\\), por exemplo. Inserindo na nossa função, teríamos então \\(f(x)=2/0,01=200\\). Se inseríssemos \\(0,001\\), obteríamos \\(f(x)=2/0,001=2000\\). O mesmo vale para valores negativos, apenas alterando o sinal do resultado. Perceba que, sendo em módulo menor do que um, quanto mais próximo de zero for o número, mais extremo será o resultado da função.↩︎\nOutra possibilidade seria adicionar um dataframe simplesmente pelo interesse em utilizar as informações que podem estar contidas nele. Por exemplo, existem pacotes que contém apenas dataframes com informações de tabelas de livros-texto específicos; com isso, os usuários ganham o poder de replicar os resultados encontrados pelo autor, facilitando o aprendizado. É importante ressaltar, contudo, que pacotes normalmente são compostos apenas por funções.↩︎\nAs documentações sempre aparecerão escritas em inglês.↩︎",
    "crumbs": [
      "R Básico",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Funções e pacotes</span>"
    ]
  },
  {
    "objectID": "dados.html",
    "href": "dados.html",
    "title": "Dados",
    "section": "",
    "text": "O sétimo capítulo te ensinará a como armazenar informações externas no R. É importante que você saiba esse tópico pois, em algumas matérias, seu professor lhe entregará arquivos com informações nos quais algumas tarefas deverão ser executadas com auxílio da linguagem. O oitavo capítulo, por sua vez, te ensinará como modificar as informações de determinada estrutura de dados.",
    "crumbs": [
      "Dados"
    ]
  },
  {
    "objectID": "importando.html",
    "href": "importando.html",
    "title": "7  Importando",
    "section": "",
    "text": "7.1 Definindo o diretório de trabalho\nAntes de importar, é interessante definirmos nosso diretório de trabalho, que corresponde ao caminho para a pasta fixa que iremos utilizar para criar ou armazenar arquivos. Pense no diretório como a pasta do seu computador que servirá como local de armazenamento de todos os arquivos relacionados ao trabalho/projeto que você estiver executando naquele momento – sejam scripts, planilhas, etc.\nPara configurar determinada pasta como diretório de trabalho, aperte Ctrl + Shift + H e, na sequência, selecione a pasta que desejar. Perceba que esse comando rodará a função setwd() no Console, cujo argumento é o caminho para a pasta. Você também pode selecionar o diretório de trabalho desta maneira direta.\nsetwd(\"caminho_para_pasta\")\nNote que, no RStudio, o caminho para o diretório atual aparece na parte superior do painel de Console, ao lado do número da versão do R que você estiver utilizando no momento. Ao mesmo tempo, você pode retornar o diretório atual de trabalho apenas rodando a função getwd(), sem nenhum argumento.",
    "crumbs": [
      "Dados",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Importando</span>"
    ]
  },
  {
    "objectID": "importando.html#funções-mais-utilizadas-para-importação",
    "href": "importando.html#funções-mais-utilizadas-para-importação",
    "title": "7  Importando",
    "section": "7.2 Funções mais utilizadas para importação",
    "text": "7.2 Funções mais utilizadas para importação\nCom o propósito de importar dados para o RStudio, iremos aprender a utilizar algumas funções específicas. Repare que estamos falando de funções, ou seja, existe mais de uma função que busca permitir com que o RStudio seja capaz de ler e armazenar dados internamente em sua memória, para posterior manipulação. Isso acontece pois não existe um único tipo de arquivo capaz de armazenar dados.\nDois pacotes serão utilizados: readr, que faz parte do tidyverse, e openxlsx. Portanto, é necessário que você os instale, caso ainda não tenha feito e, na sequência, carrege os pacotes.\n\ninstall.packages(\"readr\")\ninstall.packages(\"openxlsx\")\n\nlibrary(readr)\nlibrary(openxlsx)\n\n\n7.2.1 O pacote readr – lendo arquivos delimitados\nO pacote readr é utilizado principalmente para ler arquivos delimitados por algum caractere específico. ‘Como assim, arquivos delimitados por caractere?’ Em muitos casos, as tabelas de dados são tão grandes – ou seja, várias observações (linhas) e variáveis (colunas) – que será necessário reduzir seu tamanho com intuito de facilitar o compartilhamento com terceiros. Uma saída é comprimir todas as variáveis em uma única coluna, em que os dados são separados por algum caractere especial, mantendo o mesmo número de observações anterior. Cada linha continua representando uma observação de determinada unidade. Passamos de n observações e m colunas para n observações e 1 coluna.\n\n7.2.1.1 read_csv()\nPara começar, vamos nos concentrar no tipo de arquivo de dados retangular mais comum: CSV, que é a abreviação de Comma Separeted Values (valores separados por vírgula, em português). Abaixo, temos a aparência de um arquivo CSV simples, contendo informações de estudantes. A primeira linha, comumente chamada de cabeçalho, fornece os nomes das colunas, e as cinco linhas seguintes fornecem os dados.\n\n\nmatrícula,Nome,comida.favorita,PlanoDeRefeição,IDADE,peso\n1,Jorge,Acarajé,Regime,18,76\n2,Laís,Macarrão,Livre,23,65\n3,Matheus,Carne,Regime,22,70\n4,Laura,Frango,Livre,21,68\n5,Nathália,Peixe,Regime,21,66\n\n\nA Tabela 7.1 mostra uma representação dos mesmos dados em uma tabela.\n\n\n\n\nTabela 7.1: Dados do arquivo estudantes.csv como tabela.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmatrícula\nNome\ncomida.favorita\nPlanoDeRefeição\nIDADE\npeso\n\n\n\n\n1\nJorge\nAcarajé\nRegime\n18\n76\n\n\n2\nLaís\nMacarrão\nLivre\n23\n65\n\n\n3\nMatheus\nCarne\nRegime\n22\n70\n\n\n4\nLaura\nFrango\nLivre\n21\n68\n\n\n5\nNathália\nPeixe\nRegime\n21\n66\n\n\n\n\n\n\n\n\nQuando temos um arquivo do tipo csv, podemos importá-lo para o R usando a função read_csv(). O primeiro argumento é o mais importante: o caminho para o arquivo. Você pode pensar no caminho como o endereço do arquivo, ou seja, é o local em que ele está armazenado.\nSe o arquivo estiver no seu computador, é necessário escrever o caminho em termos de diretório e pastas, além do nome do arquivo e sua extensão. Lembre-se que já fixamos nosso diretório de trabalho. Basta então escrever o restante do caminho, considerando que o arquivo está na pasta dados1 e se chama estudantes.csv!\n\nestudantes &lt;- read_csv(\"dados/estudantes.csv\")\n## Rows: 5 Columns: 6\n## ── Column specification ────────────────────────────────────────────────────────\n## Delimiter: \",\"\n## chr (3): Nome, comida.favorita, PlanoDeRefeição\n## dbl (3): matrícula, IDADE, peso\n## \n## ℹ Use `spec()` to retrieve the full column specification for this data.\n## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nPor outro lado, você pode baixar o arquivo diretamente de algum link hospedado na internet! A vantagem dessa alternativa consiste no fato de quê você não precisará realizar novamente o download do arquivo no seu computador em caso de atualização do arquivo original – além, é claro, de tornar seu diretório de trabalho mais limpo.\n\nestudantes &lt;- read_csv(\"https://raw.githubusercontent.com/ieufrjquant/intror/master/dados/estudantes.csv\")\n\nIndependente da forma com que você especifique o caminho para o arquivo ao executar a função read_csv(), note que ela exibe uma mensagem informando o número de linhas e colunas de dados, o delimitador que foi usado e as especificações das colunas (nomes das colunas organizadas pelo tipo de dados que a coluna contém).\nObserve também que, em ambos os casos, atribuimos a tabela de dados ao objeto estudantes, ficando disponível para visualização no painel Environment. Quando for importar alguma tabela para o R, é importante que você atribua os dados a um objeto – cujo nome, como sabemos, é de livre escolha. Caso contrário, o arquivo será apenas lido no Console, ao invés de ficar efetivamente armazenado para manipulação2. Por fim, importante observar que o objeto criado terá estrutura de data frame.\n\n\n\n\n\n\nFunções para outros tipos de arquivo delimitados (Opcional)\n\n\n\n\n\nDepois de dominar read_csv(), usar as outras funções do readr é simples; é apenas uma questão de saber qual função buscar:\n\nread_csv2() lê arquivos separados por ponto e vírgula. Eles usam ; em vez de , para separar campos e são comuns em países que usam , como marcador decimal.\nread_tsv() lê arquivos delimitados por tabulações.\nread_delim() lê arquivos com qualquer delimitador, tentando adivinhar automaticamente o delimitador se você não especificá-lo.\nread_fwf() lê arquivos de largura fixa. Você pode especificar campos por suas larguras com fwf_widths() ou por suas posições com fwf_positions().\nread_table() lê uma variação comum de arquivos de largura fixa onde as colunas são separadas por espaços em branco.\n\n\n\n\n\n\n\n7.2.2 O pacote readxl – lendo planilhas\nNesta seção, iremos nos concentrar em importar dados de planilhas, especificamente os que foram agrupados em planilhas de Excel. Veremos como importar todos os dados de uma planilha com apenas uma única aba, assim como de uma aba específica, caso exista mais de uma.\n\n7.2.2.1 read.xlsx()\nA maioria dos arquivos escritos em Excel hoje possui uma extensão do tipo .xlsx. Portanto, vamos focar na função do pacote openxlsx que melhor lide com planilhas desse tipo: read.xlsx(). Como no caso anterior, note que o objeto criado terá estrutura de um data frame.\n\n7.2.2.1.1 Planilha\nEsse caso se aplica quando você desejar importar todos os dados que estão na primeira e única aba de uma planilha. O procedimento é muito parecido com o que fizemos no caso de arquivos delimitados: precisaremos do endereço para o arquivo que desejamos importar, que pode ser um caminho de pastas no seu computador ou um link externo.\n\nestudantes &lt;- read.xlsx(\"dados/estudantes.xlsx\")\nestudantes\n\n  matrícula     Nome comida.favorita PlanoDeRefeição IDADE peso\n1         1    Jorge         Acarajé          Regime    18   76\n2         2     Laís        Macarrão           Livre    23   65\n3         3  Matheus           Carne          Regime    22   70\n4         4    Laura          Frango           Livre    21   68\n5         5 Nathália           Peixe          Regime    21   66\n\n\n\n\n7.2.2.1.2 Aba específica\nPara importar dados de uma aba específica de determinada planilha é necessário especificar, além do endereço do arquivo, o nome ou o índice da aba que você deseja. No exemplo abaixo, importamos os dados completos do Maddison Project Database 2020, que estão contidos na terceira aba da planilha disponibilizada pelos organizadores.\n\ndados &lt;- read.xlsx(\"https://www.rug.nl/ggdc/historicaldevelopment/maddison/data/mpd2020.xlsx\", \n                   sheet = \"Full data\")\n\ndados &lt;- read.xlsx(\"https://www.rug.nl/ggdc/historicaldevelopment/maddison/data/mpd2020.xlsx\", \n                   sheet = 3)\n\ndados",
    "crumbs": [
      "Dados",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Importando</span>"
    ]
  },
  {
    "objectID": "importando.html#footnotes",
    "href": "importando.html#footnotes",
    "title": "7  Importando",
    "section": "",
    "text": "A pasta dados foi criada com intuito de aprimorar a organização do diretório de trabalho. Você não precisa tê-la em seu computador. Se você já fixou o diretório base, pode importar arquivos apenas com read_csv(\"nome_do_arquivo.csv\").↩︎\nÉ exatamente a mesma lógica de armazenamento vista no capítulo sobre objetos.↩︎",
    "crumbs": [
      "Dados",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Importando</span>"
    ]
  },
  {
    "objectID": "manipulando.html",
    "href": "manipulando.html",
    "title": "8  Manipulando",
    "section": "",
    "text": "8.1 Vetor\nLembre-se que um vetor é uma sequência de valores de mesmo tipo, podendo ser interpretado como uma coluna (vetor-coluna) ou como uma linha (vetor-linha). Portanto, se o combinarmos com mais uma coluna/linha, deixará de ser um vetor. Logo, nos concentraremos na substituição, transformação, adição e remoção de um dado específico. Vamos começar com um simples vetor c(4, 5, 6, 444), atirbuindo-o ao objeto de nome x.\nx &lt;- c(4, 5, 6, 444)\nx\n\n[1]   4   5   6 444",
    "crumbs": [
      "Dados",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Manipulando</span>"
    ]
  },
  {
    "objectID": "manipulando.html#dplyr",
    "href": "manipulando.html#dplyr",
    "title": "8  Manipulando",
    "section": "8.2 dplyr",
    "text": "8.2 dplyr\nA depender do nível de complexidade da tarefa que desejamos executar, as funções básicas não serão adequadas (seja por não existir uma função que faça aquele procedimento ou por complexidade de implementação/legibilidade do código).",
    "crumbs": [
      "Dados",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Manipulando</span>"
    ]
  },
  {
    "objectID": "manipulando.html#footnotes",
    "href": "manipulando.html#footnotes",
    "title": "8  Manipulando",
    "section": "",
    "text": "Não iremos, no entanto, abordar a geração de diferentes representações de uma mesma tabela de dados. Todas as tabelas que você receber estarão organizadas de forma apropriada para a execução da tarefa. De qualquer modo, caso tenha interesse em entender melhor este processo e como fazê-lo, veja o Capítulo 5 do livro R for Data Science.↩︎\nNote que c(1, 3), no interior dos colchetes, também é um vetor. Esse vetor não é armazenado na memória e, nesse contexto, serve para indicar as posições que desejamos substituir.↩︎",
    "crumbs": [
      "Dados",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Manipulando</span>"
    ]
  },
  {
    "objectID": "manipulando.html#sem-pacotes-externos",
    "href": "manipulando.html#sem-pacotes-externos",
    "title": "8  Manipulando",
    "section": "",
    "text": "8.1.1 Vetor\n\nx &lt;- c(1,2,3)\nx[2] &lt;- 555\nx\n\n[1]   1 555   3\n\n\n\n\n8.1.2 Data frame\n\ndf &lt;- data.frame(col1 = rnorm(10), \n                 col2 = rnorm(10))\ndf[4,2] &lt;- NA\ndf\n\n         col1        col2\n1   0.5516917  0.37713938\n2  -1.5455569 -0.03695570\n3  -0.5207481  1.56446332\n4   1.1435980          NA\n5  -0.5607061 -0.15537615\n6   0.5391598 -0.50128047\n7   0.2091681 -0.56662140\n8  -1.1901029  0.80446760\n9   0.4336441  1.19991619\n10 -0.2803376 -0.08687654",
    "crumbs": [
      "Dados",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Manipulando</span>"
    ]
  },
  {
    "objectID": "manipulando.html#data-frame",
    "href": "manipulando.html#data-frame",
    "title": "8  Manipulando",
    "section": "8.3 Data frame",
    "text": "8.3 Data frame\nNessa seção, iremos manipular data.frames. Nosso objeto base será o abaixo.\n\ndf &lt;- data.frame(col1 = 1:10, \n                 col2 = letters[1:10])\ndf\n\n   col1 col2\n1     1    a\n2     2    b\n3     3    c\n4     4    d\n5     5    e\n6     6    f\n7     7    g\n8     8    h\n9     9    i\n10   10    j\n\n\n\n8.3.1 Sem pacotes externos\n\ndf[2, 2] &lt;- \"Oi!\"\ndf\n\n   col1 col2\n1     1    a\n2     2  Oi!\n3     3    c\n4     4    d\n5     5    e\n6     6    f\n7     7    g\n8     8    h\n9     9    i\n10   10    j\n\n\n\ndf[c(5,2), c(1,2)] &lt;- 500\ndf\n\n   col1 col2\n1     1    a\n2   500  500\n3     3    c\n4     4    d\n5   500  500\n6     6    f\n7     7    g\n8     8    h\n9     9    i\n10   10    j\n\n\n\ndf[c(7, 8)] &lt;- c(70, 80)\n\nError in `[&lt;-.data.frame`(`*tmp*`, c(7, 8), value = c(70, 80)): novas colunas deixariam buracos em cima das colunas existentes\n\ndf\n\n   col1 col2\n1     1    a\n2   500  500\n3     3    c\n4     4    d\n5   500  500\n6     6    f\n7     7    g\n8     8    h\n9     9    i\n10   10    j\n\n\n\ndf[df == 3] &lt;- 90\ndf\n\n   col1 col2\n1     1    a\n2   500  500\n3    90    c\n4     4    d\n5   500  500\n6     6    f\n7     7    g\n8     8    h\n9     9    i\n10   10    j\n\n\n\ndf[df %in% c(1, 10)] &lt;- 0\ndf\n\n   col1 col2\n1     1    a\n2   500  500\n3    90    c\n4     4    d\n5   500  500\n6     6    f\n7     7    g\n8     8    h\n9     9    i\n10   10    j\n\n\n\ndf[1, 1] &lt;- df[1, 1] * 2\ndf\n\n   col1 col2\n1     2    a\n2   500  500\n3    90    c\n4     4    d\n5   500  500\n6     6    f\n7     7    g\n8     8    h\n9     9    i\n10   10    j\n\n\n\ndf[1, 3] &lt;- 50\ndf\n\n   col1 col2 V3\n1     2    a 50\n2   500  500 NA\n3    90    c NA\n4     4    d NA\n5   500  500 NA\n6     6    f NA\n7     7    g NA\n8     8    h NA\n9     9    i NA\n10   10    j NA\n\n\n\ndf[-3]\n\n   col1 col2\n1     2    a\n2   500  500\n3    90    c\n4     4    d\n5   500  500\n6     6    f\n7     7    g\n8     8    h\n9     9    i\n10   10    j\n\n\n\n\n8.3.2 dplyr\nA depender do nível de complexidade da tarefa que desejamos executar, as funções básicas não serão adequadas (seja por não existir uma função que faça aquele procedimento ou pela dificuldade de implementação/legibilidade do código). Nessa subseção, aprenderemos três funções do pacote dplyr que serão tornarão o processo de mainupalação mais rápido, fácil e legível.\n\n\n\n\n\n\nPipe!\n\n\n\nNa maioria dos casos, iremos utilizar funções do pacote dplyr em sequência, isto é, utilizando as transformações anteriores como input para funções seguintes. Por esse motivo, se torna comum o uso do operador Pipe %&gt;%. Não se assuste.\n\n\n\nselect\n\n\nmutate\n\n\nfilter",
    "crumbs": [
      "Dados",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Manipulando</span>"
    ]
  },
  {
    "objectID": "manipulando.html#vetor",
    "href": "manipulando.html#vetor",
    "title": "8  Manipulando",
    "section": "",
    "text": "8.1.1 Substituindo e transformando\nSe quisessemos apenas substituir o seu segundo elemento, como faríamos? Basta atribuir o novo valor que desejamos, através do operador &lt;-, à segunda posição do vetor x! Lembre-se, do Capítulo 5, que para nos referimos ao enésimo elemento de um vetor, devemos escrever seu nome, seguido de colchetes, com a posição \\(n\\) desejada na parte interior.\n\nx[2] &lt;- 444\nx\n\n[1]   4 444   6 444\n\n\nPodemos também substituir os valores de múltiplas posições, atribuindo um único valor. No exemplo abaixo, o valor 8 será atribuído às posições 1 e 32.\n\nx[c(1, 3)] &lt;- 8\nx\n\n[1]   8 444   8 444\n\n\nOu então substituir os valores de múltiplas posições, atribuindo múltiplos valores, de forma paralela. No exemplo abaixo, os valores ‘6’ e ‘12’ serão atribuídos às posições 1 e 3, respectivamente.\n\nx[c(1, 3)] &lt;- c(6, 12)\nx\n\n[1]   6 444  12 444\n\n\nAo invés de nos referirmos à posição do dado que queremos alterar, talvez seja mais útil utilizar seu valor propriamente dito, não é? Por exemplo, substituir todos os ‘444’ presentes por ‘9’. Esse procedimento pode ser feito indicando, dentro dos colchetes após o nome do vetor, que queremos nos relacionar com todos os seus elementos de valor igual a ‘444’.\n\nx[x == 444] &lt;- 9\nx\n\n[1]  6  9 12  9\n\n\nE se quiséssemos substituir valores específicos que são diferentes? Aqui, teremos que nos valer do uso do operador %in%. No exemplo abaixo, iremos substituir todos os ‘4’ e ‘9’ por ‘0’.\n\nx[x %in% c(4, 9)] &lt;- 0\nx\n\n[1]  6  0 12  0\n\n\nAlém disso, podemos, por exemplo, ter o desejo de alterar o quarto elemento do vetor x através da soma, subtração, multiplicação ou divisão. Nesse caso, devemos realizar a operação sobre o valor atual da quarta posição do vetor e atribuir o resultado, através do operador &lt;-, à essa mesma posição! Vamos multiplicá-lo por 2.\n\nx[4] &lt;- x[4] * 2\nx\n\n[1]  6  0 12  0\n\n\nA lógica de atribuição é idêntica ao do primeiro exemplo, quando substituímos o elemento da segunda posição! Por fim, note que você pode combinar todos esses comandos. No exemplo abaixo, substiutímos os valores ‘6’ e 24’ pelo valor da terceira posição, dividido por 2, somado mais 9 e 32, respectivamente.\n\nx[x %in% c(6, 12)] &lt;- c((x[3] / 2) + 9, 32)\nx\n\n[1] 15  0 32  0\n\n\n\n\n8.1.2 Adicionando e removendo\nE se quiséssemos adicionar um quinto elemento a esse vetor? Basta atribuir o valor desejado à esta posição, como se estivesse substituindo ou alterando um elemento existente! O R irá automaticamente criar esse espaço.\n\nx[5] &lt;- 7\nx\n\n[1] 15  0 32  0  7\n\n\nPor outro lado, para remover determinado valor via sua posição, escreva-a dentro dos colchetes precedida pelo sinal de - e atribua o resultado a objeto de mesmo nome.\n\nx &lt;- x[-5]\nx\n\n[1] 15  0 32  0\n\n\nVocê também pode remover elementos de um vetor que correspondam a determinados valores. Novamente, faremos uso do operador %in%. Dessa vez, também usaremos o operador de negação !.\n\nx &lt;- x[!(x %in% c(15, 32))]\nx\n\n[1] 0 0",
    "crumbs": [
      "Dados",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Manipulando</span>"
    ]
  },
  {
    "objectID": "manipulando.html#matriz",
    "href": "manipulando.html#matriz",
    "title": "8  Manipulando",
    "section": "8.2 Matriz",
    "text": "8.2 Matriz\nVamos utilizar como base a matriz contendo os números de 1 a 9, disposta em 3 linhas e 3 colunas.\n\nmatrix &lt;- matrix(c(1:9), ncol = 3)\nmatrix\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\n\n\n8.2.1 Substituindo e transformando\nObserve que agora temos uma estrutura de dados bidimensional. Isso significa que você acessar determinando valor através de sua posição, indicando a linha e a coluna em que está. Para substituir tal valor, podemos aplicar a mesma lógica que utilizamos com vetores. No exemplo abaixo, substituímos o número da posição {linha 2, coluna 2} por 1000.\n\nmatrix[2, 2] &lt;- 1000\nmatrix\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2 1000    8\n[3,]    3    6    9\n\n\nVocê também pode indicar múltiplas posições para fixar o novo valor. Nesse caso, é necessário inserir dois vetores dentro dos colchetes, represetando as linhas e colunas, respectivamente. O novo valor será atribuído a todas as combinações possíveis de posições geradas pelos vetores. Observe o exemplo abaixo. Nele, estamos substituindo os valores das posições {linha 1, coluna 2}, {linha 1, coluna 3}, {linha 2, coluna 2} e {linha 2, coluna 3} pelo número 500.\n\nmatrix[c(1,2), c(2,3)] &lt;- 500\nmatrix\n\n     [,1] [,2] [,3]\n[1,]    1  500  500\n[2,]    2  500  500\n[3,]    3    6    9\n\n\nNo entanto, esse não é o único jeito de se referir a posição de um elemento de uma matriz. Você pode acessá-lo pensando na matriz como um vetor coluna! Em outras palavras, contabilize cada valor em sequência, partindo da esquerda, de cima para baixo. Nessa indexação imaginária, podemos novamente acessar as posições {linha 1, coluna 3} e {linha 2, coluna 3} através dos índices 7 e 8, respectivamente.\n\nmatrix[c(7, 8)] &lt;- c(70, 80)\nmatrix\n\n     [,1] [,2] [,3]\n[1,]    1  500   70\n[2,]    2  500   80\n[3,]    3    6    9\n\n\nPara nos referirmos à valores propriamente ditos, o procedimento é o mesmo de um vetor.\n\nmatrix[matrix == 3] &lt;- 90\nmatrix\n\n     [,1] [,2] [,3]\n[1,]    1  500   70\n[2,]    2  500   80\n[3,]   90    6    9\n\nmatrix[matrix %in% c(1, 80)] &lt;- 0\nmatrix\n\n     [,1] [,2] [,3]\n[1,]    0  500   70\n[2,]    2  500    0\n[3,]   90    6    9\n\n\nAssim como o procedimento de alterar algum elemento específico.\n\nmatrix[2, 2] &lt;- matrix[2, 2] * 2\nmatrix\n\n     [,1] [,2] [,3]\n[1,]    0  500   70\n[2,]    2 1000    0\n[3,]   90    6    9\n\n\n\n\n8.2.2 Adicionando e removendo\nE se quiséssemos adicionar um décimo elemento a essa matriz, na posição {linha 1, coluna 4}, seria possível? A resposta é não.\n\nmatrix[1, 4] &lt;- 50\n\nError in `[&lt;-`(`*tmp*`, 1, 4, value = 50): índice fora de limites\n\n\nE se tratassemos a matriz como um vetor, como fizemos no início da subseção anterior, funcionaria? Nesse caso, até conseguiriamos atribuir o novo valor, porém a matriz seria realmente convertida em vetor!\n\nmatrix[10] &lt;- 50\nmatrix\n\n [1]    0    2   90  500 1000    6   70    0    9   50\n\n\nNa prática, para adicionar valores à uma matriz, devemos adicionar uma nova linha ou coluna, utilizando as funções rbind e cbind, respectivamente! É necessário respeitar sua forma retangular. “Mas e se não tivermos valores suficientes para preencher um linha ou coluna nova?” Você pode utilizar NA! No exemplo abaixo, adicionamos uma nova coluna a nossa matriz base.\n\nmatrix &lt;- cbind(matrix, c(10, NA, NA))\nmatrix\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   NA\n[3,]    3    6    9   NA\n\n\nPor outro lado, para remover determinada linha ou coluna, escreva seu índice dentro dos colchetes precedido pelo sinal de -, separado por vírgula – lembrando que linhas são escritas antes e colunas depois da vírgula. No final, atribua o resultado a objeto de mesmo nome. Abaixo, removendo a coluna 1 da matriz.\n\nmatrix &lt;- matrix[,-1]\nmatrix\n\n     [,1] [,2] [,3]\n[1,]    4    7   10\n[2,]    5    8   NA\n[3,]    6    9   NA\n\n\nAgora, removendo a linha 2.\n\nmatrix &lt;- matrix[-2,]\nmatrix\n\n     [,1] [,2] [,3]\n[1,]    4    7   10\n[2,]    6    9   NA",
    "crumbs": [
      "Dados",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Manipulando</span>"
    ]
  },
  {
    "objectID": "manipulando.html#substituindo-e-transformando-1",
    "href": "manipulando.html#substituindo-e-transformando-1",
    "title": "8  Manipulando",
    "section": "8.3 Substituindo e transformando",
    "text": "8.3 Substituindo e transformando\nObserve que agora temos uma estrutura de dados bidimensional. Isso significa que você acessar determinando valor através de sua posição, indicando a linha e a coluna em que está. Para substituir tal valor, podemos aplicar a mesma lógica que utilizamos com vetores. No exemplo abaixo, substituímos o número 5 por 1000.\n\nmatrix[2, 2] &lt;- 1000\nmatrix\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2 1000    8\n[3,]    3    6    9\n\n\nVocê também pode indicar múltiplas posições para fixar o novo valor. Nesse caso, é necessário inserir dois vetores dentro dos colchetes, represetando as linhas e colunas, respectivamente. O primeiro elemento do vetor à esquerda, representando o índice de uma linha, será pareado com o primeiro elemento do vetor à direita, representando o índice de uma coluna – e assim sucessivamente.\nObserve o exemplo abaixo. Nele, estamos substituindo os valores das posições {linha 1, coluna 3} e {linha 2, coluna 3} pelo número 1000.\n\nmatrix[c(1,2), c(3,3)] &lt;- 1000\nmatrix\n\n     [,1] [,2] [,3]\n[1,]    1    4 1000\n[2,]    2 1000 1000\n[3,]    3    6    9\n\n\n\nmatrix[matrix %in% c(1, 9)] &lt;- 0\nmatrix\n\n     [,1] [,2] [,3]\n[1,]    0    4 1000\n[2,]    2 1000 1000\n[3,]    3    6    0\n\n\nOu então substituir os valores de múltiplas posições, atribuindo múltiplos valores, de forma paralela. No exemplo abaixo, os valores ‘6’ e ‘12’ serão atribuídos às posições 1 e 3, respectivamente.\n\nmatrix[c(1,2), c(3,3)] &lt;- c(6, 12)\nmatrix\n\n     [,1] [,2] [,3]\n[1,]    0    4    6\n[2,]    2 1000   12\n[3,]    3    6    0\n\n\nAo invés de nos referirmos à posição do dado que queremos alterar, talvez seja mais útil utilizar seu valor propriamente dito, não é? Por exemplo, substituir todos os ‘444’ presentes por ‘9’. Esse procedimento pode ser feito indicando, dentro dos colchetes após o nome do vetor, que queremos nos relacionar com todos os seus elementos de valor igual a ‘444’.\n\nmatrix[matrix == 3] &lt;- 90\nmatrix\n\n     [,1] [,2] [,3]\n[1,]    0    4    6\n[2,]    2 1000   12\n[3,]   90    6    0\n\n\nE se quiséssemos substituir valores específicos que são diferentes? Aqui, teremos que nos valer do uso do operador %in%. No exemplo abaixo, iremos substituir todos os ‘4’ e ‘9’ por ‘0’.\n\nmatrix[matrix %in% c(1, 4)] &lt;- 0\nmatrix\n\n     [,1] [,2] [,3]\n[1,]    0    0    6\n[2,]    2 1000   12\n[3,]   90    6    0\n\n\nAlém disso, podemos, por exemplo, ter o desejo de alterar o quarto elemento do vetor x através da soma, subtração, multiplicação ou divisão. Nesse caso, devemos realizar a operação sobre o valor atual da quarta posição do vetor e atribuir o resultado, através do operador &lt;-, à essa mesma posição! Vamos multiplicá-lo por 2.\n\nmatrix[2, 2] &lt;- matrix[2, 2] * 2\nmatrix\n\n     [,1] [,2] [,3]\n[1,]    0    0    6\n[2,]    2 2000   12\n[3,]   90    6    0\n\n\nA lógica de atribuição é idêntica ao do primeiro exemplo, quando substituímos o elemento da segunda posição! Por fim, note que você pode combinar todos esses comandos. No exemplo abaixo, substiutímos os valores ‘6’ e 24’ pelo valor da terceira posição, dividido por 2, somado mais 9 e 32, respectivamente.\n\nmatrix[matrix %in% c(6, 12)] &lt;- c((matrix[2,2] / 2) + 9, 32)\n\nWarning in matrix[matrix %in% c(6, 12)] &lt;- c((matrix[2, 2]/2) + 9, 32): número\nde itens para para substituir não é um múltiplo do comprimento do substituto\n\nmatrix\n\n     [,1] [,2] [,3]\n[1,]    0    0   32\n[2,]    2 2000 1009\n[3,]   90 1009    0\n\n\n\n8.3.1 Adicionando e removendo\nE se quiséssemos adicionar um décimo elemento a essa matriz?\n\nx[5] &lt;- 7\nx\n\n[1]  0  0 NA NA  7\n\n\nPor outro lado, para remover determinado valor via sua posição, escreva-a dentro dos colchetes precedida pelo sinal de - e atribua o resultado a objeto de mesmo nome.\n\nx &lt;- x[-5]\nx\n\n[1]  0  0 NA NA\n\n\nVocê também pode remover elementos de um vetor que correspondam a determinados valores. Novamente, faremos uso do operador %in%. Dessa vez, também usaremos o operador de negação !.\n\nx &lt;- x[!(x %in% c(15, 32))]\nx\n\n[1]  0  0 NA NA",
    "crumbs": [
      "Dados",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Manipulando</span>"
    ]
  },
  {
    "objectID": "manipulando.html#dataframe",
    "href": "manipulando.html#dataframe",
    "title": "8  Manipulando",
    "section": "8.3 Dataframe",
    "text": "8.3 Dataframe\nNessa seção, iremos manipular data.frames. Vamos recapitular a Tabela 7.1, que importamos no Capítulo 7.\n\nestudantes &lt;- read_csv(\"dados/estudantes.csv\")\n\nRows: 5 Columns: 6\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): Nome, comida.favorita, PlanoDeRefeição\ndbl (3): matrícula, IDADE, peso\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nestudantes\n\n# A tibble: 5 × 6\n  matrícula Nome     comida.favorita PlanoDeRefeição IDADE  peso\n      &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;           &lt;chr&gt;           &lt;dbl&gt; &lt;dbl&gt;\n1         1 Jorge    Acarajé         Regime             18    76\n2         2 Laís     Macarrão        Livre              23    65\n3         3 Matheus  Carne           Regime             22    70\n4         4 Laura    Frango          Livre              21    68\n5         5 Nathália Peixe           Regime             21    66\n\n\n\n8.3.1 Sem pacotes externos\nMuito do que vimos com relação à matrizes se aplica aos dataframes. Com exceção do exercício imaginário do dataframe como um vetor-coluna, as tarefas de substituição e alteração podem ser realizadas da mesma forma.\n\nestudantes[2, 2] &lt;- \"Maurício\"\nestudantes\n\n# A tibble: 5 × 6\n  matrícula Nome     comida.favorita PlanoDeRefeição IDADE  peso\n      &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;           &lt;chr&gt;           &lt;dbl&gt; &lt;dbl&gt;\n1         1 Jorge    Acarajé         Regime             18    76\n2         2 Maurício Macarrão        Livre              23    65\n3         3 Matheus  Carne           Regime             22    70\n4         4 Laura    Frango          Livre              21    68\n5         5 Nathália Peixe           Regime             21    66\n\n\n\nestudantes[c(5,2), c(5,6)] &lt;- list(c(25, 23), c(70,68))\nestudantes\n\n# A tibble: 5 × 6\n  matrícula Nome     comida.favorita PlanoDeRefeição IDADE  peso\n      &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;           &lt;chr&gt;           &lt;dbl&gt; &lt;dbl&gt;\n1         1 Jorge    Acarajé         Regime             18    76\n2         2 Maurício Macarrão        Livre              23    68\n3         3 Matheus  Carne           Regime             22    70\n4         4 Laura    Frango          Livre              21    68\n5         5 Nathália Peixe           Regime             25    70\n\n\n\nestudantes[estudantes == \"Carne\"] &lt;- \"Carne Vermelha\"\nestudantes\n\n# A tibble: 5 × 6\n  matrícula Nome     comida.favorita PlanoDeRefeição IDADE  peso\n      &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;           &lt;chr&gt;           &lt;dbl&gt; &lt;dbl&gt;\n1         1 Jorge    Acarajé         Regime             18    76\n2         2 Maurício Macarrão        Livre              23    68\n3         3 Matheus  Carne Vermelha  Regime             22    70\n4         4 Laura    Frango          Livre              21    68\n5         5 Nathália Peixe           Regime             25    70\n\n\n\nestudantes$PlanoDeRefeição[estudantes$Nome %in% c(\"Jorge\", \"Maurício\")] &lt;- \"Regime Forte\" \nestudantes\n\n# A tibble: 5 × 6\n  matrícula Nome     comida.favorita PlanoDeRefeição IDADE  peso\n      &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;           &lt;chr&gt;           &lt;dbl&gt; &lt;dbl&gt;\n1         1 Jorge    Acarajé         Regime Forte       18    76\n2         2 Maurício Macarrão        Regime Forte       23    68\n3         3 Matheus  Carne Vermelha  Regime             22    70\n4         4 Laura    Frango          Livre              21    68\n5         5 Nathália Peixe           Regime             25    70\n\n\n\nestudantes[1, 5] &lt;- estudantes[1, 5] * 2\nestudantes\n\n# A tibble: 5 × 6\n  matrícula Nome     comida.favorita PlanoDeRefeição IDADE  peso\n      &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;           &lt;chr&gt;           &lt;dbl&gt; &lt;dbl&gt;\n1         1 Jorge    Acarajé         Regime Forte       36    76\n2         2 Maurício Macarrão        Regime Forte       23    68\n3         3 Matheus  Carne Vermelha  Regime             22    70\n4         4 Laura    Frango          Livre              21    68\n5         5 Nathália Peixe           Regime             25    70\n\n\nPara adicionar um novo valor, basta refenciar sua posição. Perceba que, caso não haja observações suficientes, o R automaticamente completará o restante com ´NA`.\n\nestudantes[1, 7] &lt;- 50\nestudantes\n\n# A tibble: 5 × 7\n  matrícula Nome     comida.favorita PlanoDeRefeição IDADE  peso  ...7\n      &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;           &lt;chr&gt;           &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1         1 Jorge    Acarajé         Regime Forte       36    76    50\n2         2 Maurício Macarrão        Regime Forte       23    68    NA\n3         3 Matheus  Carne Vermelha  Regime             22    70    NA\n4         4 Laura    Frango          Livre              21    68    NA\n5         5 Nathália Peixe           Regime             25    70    NA\n\n\nPara remover uma coluna, escreva seu índice entre os colchetes precedido do sinal de -. Para remover uma linha, realize o mesmo procedimento, apenas adicionando uma vírgula ao final.\n\nestudantes &lt;- estudantes[-7]\nestudantes &lt;- estudantes[-2,]\n\nestudantes\n\n# A tibble: 4 × 6\n  matrícula Nome     comida.favorita PlanoDeRefeição IDADE  peso\n      &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;           &lt;chr&gt;           &lt;dbl&gt; &lt;dbl&gt;\n1         1 Jorge    Acarajé         Regime Forte       36    76\n2         3 Matheus  Carne Vermelha  Regime             22    70\n3         4 Laura    Frango          Livre              21    68\n4         5 Nathália Peixe           Regime             25    70\n\n\n\n\n8.3.2 dplyr\nA depender do nível de complexidade da tarefa que desejamos executar, as funções básicas não serão adequadas (seja por não existir uma função que faça aquele procedimento ou pela dificuldade de implementação/legibilidade do código). Nessa subseção, aprenderemos três funções do pacote dplyr que serão tornarão o processo de mainupalação mais rápido, fácil e legível.\n\n\n\n\n\n\nPipe!\n\n\n\nNa maioria dos casos, iremos utilizar funções do pacote dplyr em sequência, isto é, utilizando as transformações anteriores como input para funções seguintes. Por esse motivo, se torna comum o uso do operador Pipe %&gt;%. Não se assuste.\n\n\nVamos retornar com o dataframe estudantes inicial. Não iremos salvar os resultados para facilitar a demonstração – mas lembre-se, caso você queira que seu dataframe permenaça com as modificações, é necessário atribuí-lo à novo objeto (ou a um objeto com mesmo nome do antigo, substiutindo-o na memória).\n\n\nRows: 5 Columns: 6\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): Nome, comida.favorita, PlanoDeRefeição\ndbl (3): matrícula, IDADE, peso\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\nselect\nImagine que você queira selecionar apenas as colunas “Nome”, “IDADE” e “Peso”. Para executar essa tarefa, podemos utilizar a função select.\n\nestudantes %&gt;% \n    select(Nome, IDADE, peso)\n\n# A tibble: 5 × 3\n  Nome     IDADE  peso\n  &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt;\n1 Jorge       18    76\n2 Laís        23    65\n3 Matheus     22    70\n4 Laura       21    68\n5 Nathália    21    66\n\n\n\n\nmutate\nAgora, imagine que você deseja alterar a coluna ‘peso’, somando mais 2 para cada observação. Você pode utilizar a função mutate.\n\nestudantes %&gt;% \n  mutate(peso = peso + 2)\n\n# A tibble: 5 × 6\n  matrícula Nome     comida.favorita PlanoDeRefeição IDADE  peso\n      &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;           &lt;chr&gt;           &lt;dbl&gt; &lt;dbl&gt;\n1         1 Jorge    Acarajé         Regime             18    78\n2         2 Laís     Macarrão        Livre              23    67\n3         3 Matheus  Carne           Regime             22    72\n4         4 Laura    Frango          Livre              21    70\n5         5 Nathália Peixe           Regime             21    68\n\n\n\n\nfilter\nPor fim, vamos supor que você queira filtrar somente as pessoas maiores de 20 anos. Para essa tarefa, podemos utilizar a função filter.\n\nestudantes %&gt;% \n  filter(IDADE &gt; 20)\n\n# A tibble: 4 × 6\n  matrícula Nome     comida.favorita PlanoDeRefeição IDADE  peso\n      &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;           &lt;chr&gt;           &lt;dbl&gt; &lt;dbl&gt;\n1         2 Laís     Macarrão        Livre              23    65\n2         3 Matheus  Carne           Regime             22    70\n3         4 Laura    Frango          Livre              21    68\n4         5 Nathália Peixe           Regime             21    66\n\n\n\n\n\n\n\n\nUtilizando as funções de forma conjunta!\n\n\n\nSe resolvermos utilizar todas essas funções ao mesmo tempo, teremos:\n\nestudantes %&gt;% \n  select(Nome, IDADE, peso) %&gt;%\n  mutate(peso = peso + 2) %&gt;% \n  filter(IDADE &gt; 20)\n\n# A tibble: 4 × 3\n  Nome     IDADE  peso\n  &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt;\n1 Laís        23    67\n2 Matheus     22    72\n3 Laura       21    70\n4 Nathália    21    68",
    "crumbs": [
      "Dados",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Manipulando</span>"
    ]
  },
  {
    "objectID": "manipulando.html#utilizando-as-funções-de-forma-conjunta",
    "href": "manipulando.html#utilizando-as-funções-de-forma-conjunta",
    "title": "8  Manipulando",
    "section": "8.4 Utilizando as funções de forma conjunta!",
    "text": "8.4 Utilizando as funções de forma conjunta!\nSe resolvermos utilizar todas essas funções ao mesmo tempo, teremos:\n\nestudantes %&gt;% \n  select(Nome, IDADE, peso) %&gt;%\n  mutate(peso = peso + 2) %&gt;% \n  filter(IDADE &gt; 20)\n\n# A tibble: 4 × 3\n  Nome     IDADE  peso\n  &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt;\n1 Laís        23    67\n2 Matheus     22    72\n3 Laura       21    70\n4 Nathália    21    68",
    "crumbs": [
      "Dados",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Manipulando</span>"
    ]
  }
]